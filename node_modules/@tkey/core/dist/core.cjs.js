/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AuthMetadata": () => (/* reexport */ src_authMetadata),
  "CoreError": () => (/* reexport */ errors),
  "Metadata": () => (/* reexport */ src_metadata),
  "default": () => (/* reexport */ core),
  "generateRandomPolynomial": () => (/* reexport */ generateRandomPolynomial),
  "lagrangeInterpolatePolynomial": () => (/* reexport */ lagrangeInterpolatePolynomial),
  "lagrangeInterpolation": () => (/* reexport */ lagrangeInterpolation),
  "polyCommitmentEval": () => (/* reexport */ polyCommitmentEval)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/classCallCheck"
const classCallCheck_namespaceObject = require("@babel/runtime/helpers/classCallCheck");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/createClass"
const createClass_namespaceObject = require("@babel/runtime/helpers/createClass");
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@tkey/common-types"
const common_types_namespaceObject = require("@tkey/common-types");
;// CONCATENATED MODULE: external "json-stable-stringify"
const external_json_stable_stringify_namespaceObject = require("json-stable-stringify");
var external_json_stable_stringify_default = /*#__PURE__*/__webpack_require__.n(external_json_stable_stringify_namespaceObject);
;// CONCATENATED MODULE: external "web3-utils"
const external_web3_utils_namespaceObject = require("web3-utils");
;// CONCATENATED MODULE: external "@babel/runtime/helpers/assertThisInitialized"
const assertThisInitialized_namespaceObject = require("@babel/runtime/helpers/assertThisInitialized");
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/inherits"
const inherits_namespaceObject = require("@babel/runtime/helpers/inherits");
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/possibleConstructorReturn"
const possibleConstructorReturn_namespaceObject = require("@babel/runtime/helpers/possibleConstructorReturn");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/getPrototypeOf"
const getPrototypeOf_namespaceObject = require("@babel/runtime/helpers/getPrototypeOf");
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf_namespaceObject);
;// CONCATENATED MODULE: ./src/errors.ts







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


/**
 * CoreError, extension for Error using CustomError
 * details: github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
 *
 * Usage:
 * 1. throw CoreError.metadataUndefined() // regularly used errors
 * 2. throw CoreError.fromCode(1304); // throw via code
 * 3. throw new CoreError(1000, "share indexes should be unique"); // for scarce errors
 *
 * Guide:
 * 1000 - core
 * 2000 - security questions
 * 3000 - webstorage
 * 4000 - common types (code reserved for future implementation)
 * 5000 - private key
 * 6000 - seed phrase
 * 7000 - share serialization
 * 8000 - share transfer
 */
var CoreError = /*#__PURE__*/function (_TkeyError) {
  inherits_default()(CoreError, _TkeyError);
  var _super = _createSuper(CoreError);
  function CoreError(code, message) {
    var _this;
    classCallCheck_default()(this, CoreError);
    // takes care of stack and proto
    _this = _super.call(this, code, message);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(assertThisInitialized_default()(_this), "name", {
      value: "CoreError"
    });
    return _this;
  }
  createClass_default()(CoreError, null, [{
    key: "fromCode",
    value: function fromCode(code) {
      var extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      return new CoreError(code, "".concat(CoreError.messages[code], " ").concat(extraMessage));
    }
  }, {
    key: "default",
    value: function _default() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return new CoreError(1000, "".concat(CoreError.messages[1000], " ").concat(extraMessage));
    }

    // Custom methods
    // Metadata
  }, {
    key: "metadataUndefined",
    value: function metadataUndefined() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1101, extraMessage);
    }
  }, {
    key: "delete1OutOf1OnlyManualSync",
    value: function delete1OutOf1OnlyManualSync() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1601, extraMessage);
    }
  }, {
    key: "metadataGetFailed",
    value: function metadataGetFailed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1102, extraMessage);
    }
  }, {
    key: "metadataPostFailed",
    value: function metadataPostFailed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1103, extraMessage);
    }

    // TkeyData
  }, {
    key: "tkeyStoreInvalid",
    value: function tkeyStoreInvalid() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1201, extraMessage);
    }
  }, {
    key: "tkeyEncryptionFailed",
    value: function tkeyEncryptionFailed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1202, extraMessage);
    }
  }, {
    key: "tkeyDecryptionFailed",
    value: function tkeyDecryptionFailed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1203, extraMessage);
    }

    // Shares
  }, {
    key: "privateKeyUnavailable",
    value: function privateKeyUnavailable() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1301, extraMessage);
    }
  }, {
    key: "unableToReconstruct",
    value: function unableToReconstruct() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1302, extraMessage);
    }
  }, {
    key: "incorrectReconstruction",
    value: function incorrectReconstruction() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1303, extraMessage);
    }
  }, {
    key: "encryptedShareStoreUnavailable",
    value: function encryptedShareStoreUnavailable() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1306, extraMessage);
    }

    // Metadata locks
  }, {
    key: "acquireLockFailed",
    value: function acquireLockFailed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1401, extraMessage);
    }
  }, {
    key: "releaseLockFailed",
    value: function releaseLockFailed() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1402, extraMessage);
    }

    // Authmetadata
  }, {
    key: "privKeyUnavailable",
    value: function privKeyUnavailable() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1501, extraMessage);
    }
  }, {
    key: "metadataPubKeyUnavailable",
    value: function metadataPubKeyUnavailable() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1502, extraMessage);
    }
  }, {
    key: "authMetadataGetUnavailable",
    value: function authMetadataGetUnavailable() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1503, extraMessage);
    }
  }, {
    key: "authMetadataSetUnavailable",
    value: function authMetadataSetUnavailable() {
      var extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return CoreError.fromCode(1504, extraMessage);
    }
  }]);
  return CoreError;
}(common_types_namespaceObject.TkeyError);
defineProperty_default()(CoreError, "messages", {
  1000: "Custom",
  // Misc
  1001: "Unable to delete service provider share",
  1002: "Wrong share index",
  1003: "Unable to updateSDK",
  // metadata
  1101: "metadata not found, SDK likely not initialized",
  1102: "getMetadata errored",
  1103: "setMetadata errored",
  1104: "previouslyFetchedCloudMetadata provided in initialization is outdated",
  1105: "previouslyFetchedCloudMetadata.nonce should never be higher than the latestShareDetails, please contact support",
  // tkeystore
  1201: "Invalid tkeyStore",
  1202: "Encryption failed",
  1203: "Decryption failed",
  // shares
  1301: "Private key not available. Please reconstruct key first",
  1302: "Unable to reconstruct",
  1303: "reconstructed key is not pub key",
  1304: "Share found in unexpected polynomial",
  1305: "Input is not supported",
  1306: "no encrypted share store for share exists",
  1307: "Share doesn't exist",
  1308: "Share was deleted",
  // lock
  1401: "Unable to acquire lock",
  1402: "Unable to release lock",
  // auth metadata
  1501: "privkey unavailable",
  1502: "metadata pubkey unavailable",
  1503: "getAuthMetadata errored",
  1504: "setAuthMetadata errored",
  1601: "delete1OutOf1 requires manualSync=true"
});
/* harmony default export */ const errors = (CoreError);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/toConsumableArray"
const toConsumableArray_namespaceObject = require("@babel/runtime/helpers/toConsumableArray");
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/asyncToGenerator"
const asyncToGenerator_namespaceObject = require("@babel/runtime/helpers/asyncToGenerator");
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/regenerator"
const regenerator_namespaceObject = require("@babel/runtime/regenerator");
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator_namespaceObject);
;// CONCATENATED MODULE: external "bn.js"
const external_bn_js_namespaceObject = require("bn.js");
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/eccrypto"
const eccrypto_namespaceObject = require("@toruslabs/eccrypto");
;// CONCATENATED MODULE: ./src/lagrangeInterpolatePolynomial.ts





var generateEmptyBNArray = function generateEmptyBNArray(length) {
  return Array.from({
    length: length
  }, function () {
    return new (external_bn_js_default())(0);
  });
};
var denominator = function denominator(i, innerPoints) {
  var result = new (external_bn_js_default())(1);
  var xi = innerPoints[i].x;
  for (var j = innerPoints.length - 1; j >= 0; j -= 1) {
    if (i !== j) {
      var tmp = new (external_bn_js_default())(xi);
      tmp = tmp.sub(innerPoints[j].x);
      tmp = tmp.umod(common_types_namespaceObject.ecCurve.curve.n);
      result = result.mul(tmp);
      result = result.umod(common_types_namespaceObject.ecCurve.curve.n);
    }
  }
  return result;
};
var interpolationPoly = function interpolationPoly(i, innerPoints) {
  var coefficients = generateEmptyBNArray(innerPoints.length);
  var d = denominator(i, innerPoints);
  if (d.cmp(new (external_bn_js_default())(0)) === 0) {
    throw errors["default"]("Denominator for interpolationPoly is 0");
  }
  coefficients[0] = d.invm(common_types_namespaceObject.ecCurve.curve.n);
  for (var k = 0; k < innerPoints.length; k += 1) {
    var newCoefficients = generateEmptyBNArray(innerPoints.length);
    if (k !== i) {
      var j = void 0;
      if (k < i) {
        j = k + 1;
      } else {
        j = k;
      }
      j -= 1;
      for (; j >= 0; j -= 1) {
        newCoefficients[j + 1] = newCoefficients[j + 1].add(coefficients[j]);
        newCoefficients[j + 1] = newCoefficients[j + 1].umod(common_types_namespaceObject.ecCurve.curve.n);
        var tmp = new (external_bn_js_default())(innerPoints[k].x);
        tmp = tmp.mul(coefficients[j]);
        tmp = tmp.umod(common_types_namespaceObject.ecCurve.curve.n);
        newCoefficients[j] = newCoefficients[j].sub(tmp);
        newCoefficients[j] = newCoefficients[j].umod(common_types_namespaceObject.ecCurve.curve.n);
      }
      coefficients = newCoefficients;
    }
  }
  return coefficients;
};
var pointSort = function pointSort(innerPoints) {
  var pointArrClone = toConsumableArray_default()(innerPoints);
  pointArrClone.sort(function (a, b) {
    return a.x.cmp(b.x);
  });
  return pointArrClone;
};
var lagrange = function lagrange(unsortedPoints) {
  var sortedPoints = pointSort(unsortedPoints);
  var polynomial = generateEmptyBNArray(sortedPoints.length);
  for (var i = 0; i < sortedPoints.length; i += 1) {
    var coefficients = interpolationPoly(i, sortedPoints);
    for (var k = 0; k < sortedPoints.length; k += 1) {
      var tmp = new (external_bn_js_default())(sortedPoints[i].y);
      tmp = tmp.mul(coefficients[k]);
      polynomial[k] = polynomial[k].add(tmp);
      polynomial[k] = polynomial[k].umod(common_types_namespaceObject.ecCurve.curve.n);
    }
  }
  return new common_types_namespaceObject.Polynomial(polynomial);
};
function lagrangeInterpolatePolynomial(points) {
  return lagrange(points);
}
function lagrangeInterpolation(shares, nodeIndex) {
  if (shares.length !== nodeIndex.length) {
    throw errors["default"]("shares not equal to nodeIndex length in lagrangeInterpolation");
  }
  var secret = new (external_bn_js_default())(0);
  for (var i = 0; i < shares.length; i += 1) {
    var upper = new (external_bn_js_default())(1);
    var lower = new (external_bn_js_default())(1);
    for (var j = 0; j < shares.length; j += 1) {
      if (i !== j) {
        upper = upper.mul(nodeIndex[j].neg());
        upper = upper.umod(common_types_namespaceObject.ecCurve.curve.n);
        var temp = nodeIndex[i].sub(nodeIndex[j]);
        temp = temp.umod(common_types_namespaceObject.ecCurve.curve.n);
        lower = lower.mul(temp).umod(common_types_namespaceObject.ecCurve.curve.n);
      }
    }
    var delta = upper.mul(lower.invm(common_types_namespaceObject.ecCurve.curve.n)).umod(common_types_namespaceObject.ecCurve.curve.n);
    delta = delta.mul(shares[i]).umod(common_types_namespaceObject.ecCurve.curve.n);
    secret = secret.add(delta);
  }
  return secret.umod(common_types_namespaceObject.ecCurve.curve.n);
}

// generateRandomPolynomial - determinisiticShares are assumed random
function generateRandomPolynomial(degree, secret, deterministicShares) {
  var actualS = secret;
  if (!secret) {
    actualS = (0,common_types_namespaceObject.generatePrivateExcludingIndexes)([new (external_bn_js_default())(0)]);
  }
  if (!deterministicShares) {
    var poly = [actualS];
    for (var i = 0; i < degree; i += 1) {
      var share = (0,common_types_namespaceObject.generatePrivateExcludingIndexes)(poly);
      poly.push(share);
    }
    return new common_types_namespaceObject.Polynomial(poly);
  }
  if (!Array.isArray(deterministicShares)) {
    throw errors["default"]("deterministic shares in generateRandomPolynomial should be an array");
  }
  if (deterministicShares.length > degree) {
    throw errors["default"]("deterministicShares in generateRandomPolynomial should be less or equal than degree to ensure an element of randomness");
  }
  var points = {};
  deterministicShares.forEach(function (share) {
    points[share.shareIndex.toString("hex")] = new common_types_namespaceObject.Point(share.shareIndex, share.share);
  });
  for (var _i = 0; _i < degree - deterministicShares.length; _i += 1) {
    var shareIndex = (0,common_types_namespaceObject.generatePrivateExcludingIndexes)([new (external_bn_js_default())(0)]);
    while (points[shareIndex.toString("hex")] !== undefined) {
      shareIndex = (0,common_types_namespaceObject.generatePrivateExcludingIndexes)([new (external_bn_js_default())(0)]);
    }
    points[shareIndex.toString("hex")] = new common_types_namespaceObject.Point(shareIndex, new (external_bn_js_default())((0,eccrypto_namespaceObject.generatePrivate)()));
  }
  points["0"] = new common_types_namespaceObject.Point(new (external_bn_js_default())(0), actualS);
  return lagrangeInterpolatePolynomial(Object.values(points));
}

//  2 + 3x = y | secret for index 1 is 5 >>> g^5 is the commitment | now we have g^2, g^3 and 1, |
function polyCommitmentEval(polyCommitments, index) {
  // convert to base points, this is badly written, its the only way to access the point rn zzz TODO: refactor
  var basePtPolyCommitments = [];
  for (var i = 0; i < polyCommitments.length; i += 1) {
    var key = common_types_namespaceObject.ecCurve.keyFromPublic({
      x: polyCommitments[i].x.toString("hex"),
      y: polyCommitments[i].y.toString("hex")
    }, "");
    basePtPolyCommitments.push(key.getPublic());
  }
  var shareCommitment = basePtPolyCommitments[0];
  for (var _i2 = 1; _i2 < basePtPolyCommitments.length; _i2 += 1) {
    var factor = index.pow(new (external_bn_js_default())(_i2)).umod(common_types_namespaceObject.ecCurve.n);
    var e = basePtPolyCommitments[_i2].mul(factor);
    shareCommitment = shareCommitment.add(e);
  }
  return new common_types_namespaceObject.Point(shareCommitment.getX(), shareCommitment.getY());
}
;// CONCATENATED MODULE: ./src/metadata.ts











var Metadata = /*#__PURE__*/function () {
  // Tuple of PolyID and array of ShareIndexes

  function Metadata(input) {
    classCallCheck_default()(this, Metadata);
    defineProperty_default()(this, "pubKey", void 0);
    defineProperty_default()(this, "publicPolynomials", void 0);
    defineProperty_default()(this, "publicShares", void 0);
    defineProperty_default()(this, "polyIDList", void 0);
    defineProperty_default()(this, "generalStore", void 0);
    defineProperty_default()(this, "tkeyStore", void 0);
    defineProperty_default()(this, "scopedStore", void 0);
    defineProperty_default()(this, "nonce", void 0);
    this.publicPolynomials = {};
    this.publicShares = {};
    this.generalStore = {};
    this.tkeyStore = {};
    this.scopedStore = {};
    this.pubKey = input;
    this.polyIDList = [];
    this.nonce = 0;
  }
  createClass_default()(Metadata, [{
    key: "getShareIndexesForPolynomial",
    value: function getShareIndexesForPolynomial(polyID) {
      var matchingPolyIDs = this.polyIDList.filter(function (tuple) {
        return tuple[0] === polyID;
      });
      if (matchingPolyIDs.length < 1) {
        throw errors["default"]("there is no matching polyID");
      } else if (matchingPolyIDs.length > 1) {
        throw errors["default"]("there is more than one matching polyID");
      }
      return matchingPolyIDs[0][1];
    }
  }, {
    key: "getLatestPublicPolynomial",
    value: function getLatestPublicPolynomial() {
      return this.publicPolynomials[this.polyIDList[this.polyIDList.length - 1][0]];
    }
  }, {
    key: "addPublicShare",
    value: function addPublicShare(polynomialID, publicShare) {
      if (!(polynomialID in this.publicShares)) {
        this.publicShares[polynomialID] = {};
      }
      this.publicShares[polynomialID][publicShare.shareIndex.toString("hex")] = publicShare;
    }

    // getPublicShare(polynomialID: PolynomialID, shareIndex: BN): PublicShare {

    // }
  }, {
    key: "setGeneralStoreDomain",
    value: function setGeneralStoreDomain(key, obj) {
      this.generalStore[key] = obj;
    }
  }, {
    key: "getGeneralStoreDomain",
    value: function getGeneralStoreDomain(key) {
      return this.generalStore[key];
    }
  }, {
    key: "deleteGeneralStoreDomain",
    value: function deleteGeneralStoreDomain(key) {
      delete this.generalStore[key];
    }
  }, {
    key: "setTkeyStoreDomain",
    value: function setTkeyStoreDomain(key, arr) {
      this.tkeyStore[key] = arr;
    }
  }, {
    key: "getTkeyStoreDomain",
    value: function getTkeyStoreDomain(key) {
      return this.tkeyStore[key];
    }

    // appends shares and public polynomial to metadata.
    // should represent a generation of share or edit of threshold
  }, {
    key: "addFromPolynomialAndShares",
    value: function addFromPolynomialAndShares(polynomial, shares) {
      var publicPolynomial = polynomial.getPublicPolynomial();
      var polyID = publicPolynomial.getPolynomialID();
      this.publicPolynomials[polyID] = publicPolynomial;
      var shareIndexArr = [];
      if (Array.isArray(shares)) {
        for (var i = 0; i < shares.length; i += 1) {
          this.addPublicShare(publicPolynomial.getPolynomialID(), shares[i].getPublicShare());
          shareIndexArr.push(shares[i].shareIndex.toString("hex"));
        }
      } else {
        for (var k in shares) {
          if (Object.prototype.hasOwnProperty.call(shares, k)) {
            this.addPublicShare(publicPolynomial.getPolynomialID(), shares[k].getPublicShare());
            shareIndexArr.push(shares[k].shareIndex.toString("hex"));
          }
        }
      }
      this.polyIDList.push([polyID, shareIndexArr]);
    }
  }, {
    key: "setScopedStore",
    value: function setScopedStore(domain, data) {
      this.scopedStore[domain] = data;
    }
  }, {
    key: "getEncryptedShare",
    value: function () {
      var _getEncryptedShare = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee(shareStore) {
        var pubShare, encryptedShareStore, encryptedShare, rawDecrypted;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                pubShare = shareStore.share.getPublicShare();
                encryptedShareStore = this.scopedStore.encryptedShares;
                if (encryptedShareStore) {
                  _context.next = 4;
                  break;
                }
                throw errors.encryptedShareStoreUnavailable("".concat(shareStore));
              case 4:
                encryptedShare = encryptedShareStore[pubShare.shareCommitment.x.toString("hex")];
                if (encryptedShare) {
                  _context.next = 7;
                  break;
                }
                throw errors.encryptedShareStoreUnavailable("".concat(shareStore));
              case 7:
                _context.next = 9;
                return (0,common_types_namespaceObject.decrypt)((0,common_types_namespaceObject.toPrivKeyECC)(shareStore.share.share), encryptedShare);
              case 9:
                rawDecrypted = _context.sent;
                return _context.abrupt("return", common_types_namespaceObject.ShareStore.fromJSON(JSON.parse(rawDecrypted.toString())));
              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function getEncryptedShare(_x) {
        return _getEncryptedShare.apply(this, arguments);
      }
      return getEncryptedShare;
    }()
  }, {
    key: "getShareDescription",
    value: function getShareDescription() {
      return this.getGeneralStoreDomain("shareDescriptions");
    }
  }, {
    key: "addShareDescription",
    value: function addShareDescription(shareIndex, description) {
      var currentSD = this.getGeneralStoreDomain("shareDescriptions") || {};
      if (currentSD[shareIndex]) {
        currentSD[shareIndex].push(description);
      } else {
        currentSD[shareIndex] = [description];
      }
      this.setGeneralStoreDomain("shareDescriptions", currentSD);
    }
  }, {
    key: "deleteShareDescription",
    value: function deleteShareDescription(shareIndex, description) {
      var currentSD = this.getGeneralStoreDomain("shareDescriptions");
      var index = currentSD[shareIndex].indexOf(description);
      if (index > -1) {
        currentSD[shareIndex].splice(index, 1);
      } else {
        throw errors["default"]("No share description found for the given shareIndex: ".concat(shareIndex, " \n        and description: ").concat(description));
      }
    }
  }, {
    key: "updateShareDescription",
    value: function updateShareDescription(shareIndex, oldDescription, newDescription) {
      var currentSD = this.getGeneralStoreDomain("shareDescriptions");
      var index = currentSD[shareIndex].indexOf(oldDescription);
      if (index > -1) {
        currentSD[shareIndex][index] = newDescription;
      } else {
        throw errors["default"]("No share description found for the given shareIndex:\n        ".concat(shareIndex, " and description: ").concat(oldDescription));
      }
    }
  }, {
    key: "shareToShareStore",
    value: function shareToShareStore(share) {
      var pubkey = (0,common_types_namespaceObject.getPubKeyPoint)(share);
      var returnShare;
      for (var i = this.polyIDList.length - 1; i >= 0; i -= 1) {
        var el = this.polyIDList[i][0];
        for (var t = 0; t < this.polyIDList[i][1].length; t += 1) {
          var shareIndex = this.polyIDList[i][1][t];
          // find pubshare in cache if its there
          var pubShare = void 0;
          if (this.publicShares[el]) {
            if (this.publicShares[el][shareIndex]) {
              pubShare = this.publicShares[el][shareIndex];
            }
          }

          // if not reconstruct
          if (!pubShare) {
            pubShare = new common_types_namespaceObject.PublicShare(shareIndex, polyCommitmentEval(this.publicPolynomials[el].polynomialCommitments, new (external_bn_js_default())(shareIndex, "hex")));
          }
          if (pubShare.shareCommitment.x.eq(pubkey.x) && pubShare.shareCommitment.y.eq(pubkey.y)) {
            var tempShare = new common_types_namespaceObject.Share(pubShare.shareIndex, share);
            return new common_types_namespaceObject.ShareStore(tempShare, el);
          }
        }
      }
      if (!returnShare) {
        throw errors.fromCode(1307);
      }
      return returnShare;
    }
  }, {
    key: "clone",
    value: function clone() {
      return Metadata.fromJSON(JSON.parse(external_json_stable_stringify_default()(this)));
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      // squash data to serialized polyID according to spec
      var serializedPolyIDList = [];
      for (var i = 0; i < this.polyIDList.length; i += 1) {
        var _polyID$split$concat;
        var polyID = this.polyIDList[i][0];
        var shareIndexes = this.polyIDList[i][1];
        var sortedShareIndexes = shareIndexes.sort(function (a, b) {
          return new (external_bn_js_default())(a, "hex").cmp(new (external_bn_js_default())(b, "hex"));
        });
        var serializedPolyID = (_polyID$split$concat = polyID.split("|").concat("0x0")).concat.apply(_polyID$split$concat, toConsumableArray_default()(sortedShareIndexes)).join("|");
        serializedPolyIDList.push(serializedPolyID);
      }
      return {
        pubKey: this.pubKey.encode("elliptic-compressed", {
          ec: common_types_namespaceObject.ecCurve
        }).toString(),
        polyIDList: serializedPolyIDList,
        scopedStore: this.scopedStore,
        generalStore: this.generalStore,
        tkeyStore: this.tkeyStore,
        nonce: this.nonce
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var pubKey = value.pubKey,
        polyIDList = value.polyIDList,
        generalStore = value.generalStore,
        tkeyStore = value.tkeyStore,
        scopedStore = value.scopedStore,
        nonce = value.nonce;
      var point = common_types_namespaceObject.Point.fromCompressedPub(pubKey);
      var metadata = new Metadata(point);
      var unserializedPolyIDList = [];
      if (generalStore) metadata.generalStore = generalStore;
      if (tkeyStore) metadata.tkeyStore = tkeyStore;
      if (scopedStore) metadata.scopedStore = scopedStore;
      if (nonce) metadata.nonce = nonce;
      var _loop = function _loop(i) {
        var serializedPolyID = polyIDList[i];
        var arrPolyID = serializedPolyID.split("|");
        var zeroIndex = arrPolyID.findIndex(function (v) {
          return v === "0x0";
        });
        var firstHalf = arrPolyID.slice(0, zeroIndex);
        var secondHalf = arrPolyID.slice(zeroIndex + 1, arrPolyID.length);
        // for publicPolynomials
        var pubPolyID = firstHalf.join("|");
        var pointCommitments = [];
        firstHalf.forEach(function (compressedCommitment) {
          pointCommitments.push(common_types_namespaceObject.Point.fromCompressedPub(compressedCommitment));
        });
        var publicPolynomial = new common_types_namespaceObject.PublicPolynomial(pointCommitments);
        metadata.publicPolynomials[pubPolyID] = publicPolynomial;

        // for polyIDList
        unserializedPolyIDList.push([pubPolyID, secondHalf]);
      };
      for (var i = 0; i < polyIDList.length; i += 1) {
        _loop(i);
      }
      metadata.polyIDList = unserializedPolyIDList;
      return metadata;
    }
  }]);
  return Metadata;
}();
/* harmony default export */ const src_metadata = (Metadata);
;// CONCATENATED MODULE: ./src/authMetadata.ts








var AuthMetadata = /*#__PURE__*/function () {
  function AuthMetadata(metadata, privKey) {
    classCallCheck_default()(this, AuthMetadata);
    defineProperty_default()(this, "metadata", void 0);
    defineProperty_default()(this, "privKey", void 0);
    this.metadata = metadata;
    this.privKey = privKey;
  }
  createClass_default()(AuthMetadata, [{
    key: "toJSON",
    value: function toJSON() {
      var data = this.metadata;
      if (!this.privKey) throw errors.privKeyUnavailable();
      var k = (0,common_types_namespaceObject.toPrivKeyEC)(this.privKey);
      var sig = k.sign((0,common_types_namespaceObject.stripHexPrefix)((0,external_web3_utils_namespaceObject.keccak256)(external_json_stable_stringify_default()(data))));
      return {
        data: data,
        sig: sig.toDER("hex")
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(value) {
      var data = value.data,
        sig = value.sig;
      var m = src_metadata.fromJSON(data);
      if (!m.pubKey) throw errors.metadataPubKeyUnavailable();
      var pubK = common_types_namespaceObject.ecCurve.keyFromPublic({
        x: m.pubKey.x.toString("hex", 64),
        y: m.pubKey.y.toString("hex", 64)
      }, "hex");
      if (!pubK.verify((0,common_types_namespaceObject.stripHexPrefix)((0,external_web3_utils_namespaceObject.keccak256)(external_json_stable_stringify_default()(data))), sig)) {
        throw errors["default"]("Signature not valid for returning metadata");
      }
      return new AuthMetadata(m);
    }
  }]);
  return AuthMetadata;
}();
/* harmony default export */ const src_authMetadata = (AuthMetadata);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/typeof"
const typeof_namespaceObject = require("@babel/runtime/helpers/typeof");
var typeof_default = /*#__PURE__*/__webpack_require__.n(typeof_namespaceObject);
;// CONCATENATED MODULE: ./src/core.ts






function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }










// TODO: handle errors for get and set with retries
var ThresholdKey = /*#__PURE__*/function () {
  function ThresholdKey(args) {
    classCallCheck_default()(this, ThresholdKey);
    defineProperty_default()(this, "modules", void 0);
    defineProperty_default()(this, "enableLogging", void 0);
    defineProperty_default()(this, "serviceProvider", void 0);
    defineProperty_default()(this, "storageLayer", void 0);
    defineProperty_default()(this, "shares", void 0);
    defineProperty_default()(this, "privKey", void 0);
    defineProperty_default()(this, "lastFetchedCloudMetadata", void 0);
    defineProperty_default()(this, "metadata", void 0);
    defineProperty_default()(this, "manualSync", void 0);
    defineProperty_default()(this, "_localMetadataTransitions", void 0);
    defineProperty_default()(this, "_refreshMiddleware", void 0);
    defineProperty_default()(this, "_reconstructKeyMiddleware", void 0);
    defineProperty_default()(this, "_shareSerializationMiddleware", void 0);
    defineProperty_default()(this, "storeDeviceShare", void 0);
    defineProperty_default()(this, "haveWriteMetadataLock", void 0);
    var _ref = args || {},
      _ref$enableLogging = _ref.enableLogging,
      enableLogging = _ref$enableLogging === void 0 ? false : _ref$enableLogging,
      _ref$modules = _ref.modules,
      modules = _ref$modules === void 0 ? {} : _ref$modules,
      serviceProvider = _ref.serviceProvider,
      storageLayer = _ref.storageLayer,
      _ref$manualSync = _ref.manualSync,
      manualSync = _ref$manualSync === void 0 ? false : _ref$manualSync;
    this.enableLogging = enableLogging;
    this.serviceProvider = serviceProvider;
    this.storageLayer = storageLayer;
    this.modules = modules;
    this.shares = {};
    this.privKey = undefined;
    this.manualSync = manualSync;
    this._refreshMiddleware = {};
    this._reconstructKeyMiddleware = {};
    this._shareSerializationMiddleware = undefined;
    this.storeDeviceShare = undefined;
    this._localMetadataTransitions = [[], []];
    this.setModuleReferences(); // Providing ITKeyApi access to modules
    this.haveWriteMetadataLock = "";
  }
  createClass_default()(ThresholdKey, [{
    key: "getStorageLayer",
    value: function getStorageLayer() {
      return this.storageLayer;
    }
  }, {
    key: "getMetadata",
    value: function getMetadata() {
      if (typeof this.metadata !== "undefined") {
        return this.metadata;
      }
      throw errors.metadataUndefined();
    }
  }, {
    key: "initialize",
    value: function () {
      var _initialize = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee(params) {
        var p, withShare, importKey, neverInitializeNewKey, transitionMetadata, previouslyFetchedCloudMetadata, previousLocalMetadataTransitions, previousLocalMetadataTransitionsExists, reinitializing, reinitializingWithNewKeyAssign, shareStore, spIncludeLocalMetadataTransitions, spLocalMetadataTransitions, rawServiceProviderShare, noKeyFound, currentMetadata, latestCloudMetadata, latestShareDetails, noMetadataExistsForShare, latestShare;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // setup initial params/states
                p = params || {};
                if (!(p.delete1OutOf1 && !this.manualSync)) {
                  _context.next = 3;
                  break;
                }
                throw errors.delete1OutOf1OnlyManualSync();
              case 3:
                withShare = p.withShare, importKey = p.importKey, neverInitializeNewKey = p.neverInitializeNewKey, transitionMetadata = p.transitionMetadata, previouslyFetchedCloudMetadata = p.previouslyFetchedCloudMetadata, previousLocalMetadataTransitions = p.previousLocalMetadataTransitions;
                previousLocalMetadataTransitionsExists = previousLocalMetadataTransitions && previousLocalMetadataTransitions[0].length > 0 && previousLocalMetadataTransitions[1].length > 0;
                reinitializing = transitionMetadata && previousLocalMetadataTransitionsExists; // are we reinitializing the SDK?
                // in the case we're reinitializing whilst newKeyAssign has not been synced
                reinitializingWithNewKeyAssign = reinitializing && previouslyFetchedCloudMetadata === undefined;
                if (!(withShare instanceof common_types_namespaceObject.ShareStore)) {
                  _context.next = 11;
                  break;
                }
                shareStore = withShare;
                _context.next = 32;
                break;
              case 11:
                if (!(typeof_default()(withShare) === "object")) {
                  _context.next = 15;
                  break;
                }
                shareStore = common_types_namespaceObject.ShareStore.fromJSON(withShare);
                _context.next = 32;
                break;
              case 15:
                if (withShare) {
                  _context.next = 31;
                  break;
                }
                // default to use service provider
                // first we see if a share has been kept for us
                spIncludeLocalMetadataTransitions = reinitializingWithNewKeyAssign;
                spLocalMetadataTransitions = reinitializingWithNewKeyAssign ? previousLocalMetadataTransitions : undefined;
                _context.next = 20;
                return this.getGenericMetadataWithTransitionStates({
                  serviceProvider: this.serviceProvider,
                  includeLocalMetadataTransitions: spIncludeLocalMetadataTransitions,
                  _localMetadataTransitions: spLocalMetadataTransitions,
                  fromJSONConstructor: {
                    fromJSON: function fromJSON(val) {
                      return val;
                    }
                  }
                });
              case 20:
                rawServiceProviderShare = _context.sent;
                noKeyFound = rawServiceProviderShare;
                if (!(noKeyFound.message === common_types_namespaceObject.KEY_NOT_FOUND)) {
                  _context.next = 28;
                  break;
                }
                if (!neverInitializeNewKey) {
                  _context.next = 25;
                  break;
                }
                throw errors["default"]("key has not been generated yet");
              case 25:
                _context.next = 27;
                return this._initializeNewKey({
                  initializeModules: true,
                  importedKey: importKey,
                  delete1OutOf1: p.delete1OutOf1
                });
              case 27:
                return _context.abrupt("return", this.getKeyDetails());
              case 28:
                // else we continue with catching up share and metadata
                shareStore = common_types_namespaceObject.ShareStore.fromJSON(rawServiceProviderShare);
                _context.next = 32;
                break;
              case 31:
                throw errors["default"]("Input is not supported");
              case 32:
                _context.prev = 32;
                _context.next = 35;
                return this.catchupToLatestShare({
                  shareStore: shareStore
                });
              case 35:
                latestShareDetails = _context.sent;
                _context.next = 43;
                break;
              case 38:
                _context.prev = 38;
                _context.t0 = _context["catch"](32);
                // check if error is not the undefined error
                // if so we don't throw immediately incase there is valid transition metadata
                noMetadataExistsForShare = _context.t0.code === 1503;
                if (!(!noMetadataExistsForShare || !reinitializing)) {
                  _context.next = 43;
                  break;
                }
                throw _context.t0;
              case 43:
                if (!(reinitializing && !reinitializingWithNewKeyAssign)) {
                  _context.next = 53;
                  break;
                }
                if (!(previouslyFetchedCloudMetadata.nonce < latestShareDetails.shareMetadata.nonce)) {
                  _context.next = 48;
                  break;
                }
                throw errors.fromCode(1104);
              case 48:
                if (!(previouslyFetchedCloudMetadata.nonce > latestShareDetails.shareMetadata.nonce)) {
                  _context.next = 50;
                  break;
                }
                throw errors.fromCode(1105);
              case 50:
                latestCloudMetadata = previouslyFetchedCloudMetadata;
                _context.next = 54;
                break;
              case 53:
                latestCloudMetadata = latestShareDetails ? latestShareDetails.shareMetadata.clone() : undefined;
              case 54:
                // If we've been provided with transition metadata we use that as the current metadata instead
                // as we want to maintain state before and after serialization.
                // (Given that the checks for cloud metadata pass)
                if (reinitializing) {
                  currentMetadata = transitionMetadata;
                  this._localMetadataTransitions = previousLocalMetadataTransitions;
                } else {
                  currentMetadata = latestShareDetails.shareMetadata;
                }
                this.lastFetchedCloudMetadata = latestCloudMetadata;
                this.metadata = currentMetadata;
                latestShare = latestShareDetails ? latestShareDetails.latestShare : shareStore;
                this.inputShareStore(latestShare);

                // initialize modules
                _context.next = 61;
                return this.initializeModules();
              case 61:
                return _context.abrupt("return", this.getKeyDetails());
              case 62:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[32, 38]]);
      }));
      function initialize(_x) {
        return _initialize.apply(this, arguments);
      }
      return initialize;
    }()
    /**
     * catchupToLatestShare recursively loops fetches metadata of the provided share and checks if there is an encrypted share for it.
     * @param shareStore - share to start of with
     * @param polyID - if specified, polyID to refresh to if it exists
     */
  }, {
    key: "catchupToLatestShare",
    value: function () {
      var _catchupToLatestShare = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee2(params) {
        var shareStore, polyID, includeLocalMetadataTransitions, shareMetadata, nextShare;
        return regenerator_default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                shareStore = params.shareStore, polyID = params.polyID, includeLocalMetadataTransitions = params.includeLocalMetadataTransitions;
                _context2.prev = 1;
                _context2.next = 4;
                return this.getAuthMetadata({
                  privKey: shareStore.share.share,
                  includeLocalMetadataTransitions: includeLocalMetadataTransitions
                });
              case 4:
                shareMetadata = _context2.sent;
                _context2.next = 12;
                break;
              case 7:
                _context2.prev = 7;
                _context2.t0 = _context2["catch"](1);
                if (!(_context2.t0 && _context2.t0.code === 1308)) {
                  _context2.next = 11;
                  break;
                }
                throw _context2.t0;
              case 11:
                throw errors.authMetadataGetUnavailable(", ".concat((0,common_types_namespaceObject.prettyPrintError)(_context2.t0)));
              case 12:
                _context2.prev = 12;
                if (!polyID) {
                  _context2.next = 16;
                  break;
                }
                if (!(shareStore.polynomialID === polyID)) {
                  _context2.next = 16;
                  break;
                }
                return _context2.abrupt("return", {
                  latestShare: shareStore,
                  shareMetadata: shareMetadata
                });
              case 16:
                _context2.next = 18;
                return shareMetadata.getEncryptedShare(shareStore);
              case 18:
                nextShare = _context2.sent;
                _context2.next = 21;
                return this.catchupToLatestShare({
                  shareStore: nextShare,
                  polyID: polyID,
                  includeLocalMetadataTransitions: includeLocalMetadataTransitions
                });
              case 21:
                return _context2.abrupt("return", _context2.sent);
              case 24:
                _context2.prev = 24;
                _context2.t1 = _context2["catch"](12);
                if (!(_context2.t1 && _context2.t1.code === 1308)) {
                  _context2.next = 28;
                  break;
                }
                throw _context2.t1;
              case 28:
                return _context2.abrupt("return", {
                  latestShare: shareStore,
                  shareMetadata: shareMetadata
                });
              case 29:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 7], [12, 24]]);
      }));
      function catchupToLatestShare(_x2) {
        return _catchupToLatestShare.apply(this, arguments);
      }
      return catchupToLatestShare;
    }()
  }, {
    key: "reconstructKey",
    value: function () {
      var _reconstructKey = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee4() {
        var _this = this;
        var _reconstructKeyMiddleware,
          pubPoly,
          requiredThreshold,
          pubPolyID,
          sharesLeft,
          fullShareList,
          shareIndexesRequired,
          i,
          sharesToInput,
          z,
          sharesForPoly,
          shareIndexesForPoly,
          k,
          currentShareForPoly,
          latestShareRes,
          polyShares,
          shareArr,
          shareIndexArr,
          _i,
          privKey,
          reconstructedPubKey,
          returnObject,
          _args4 = arguments;
        return regenerator_default().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _reconstructKeyMiddleware = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : true;
                if (this.metadata) {
                  _context4.next = 3;
                  break;
                }
                throw errors.metadataUndefined();
              case 3:
                pubPoly = this.metadata.getLatestPublicPolynomial();
                requiredThreshold = pubPoly.getThreshold();
                pubPolyID = pubPoly.getPolynomialID(); // check if we have enough shares to meet threshold
                sharesLeft = requiredThreshold; // we don't just check the latest poly but
                // we check if the shares on previous polynomials in our stores have the share indexes we require
                fullShareList = this.metadata.getShareIndexesForPolynomial(pubPolyID);
                shareIndexesRequired = {};
                for (i = 0; i < fullShareList.length; i += 1) {
                  shareIndexesRequired[fullShareList[i]] = true;
                }
                sharesToInput = [];
                z = this.metadata.polyIDList.length - 1;
              case 12:
                if (!(z >= 0 && sharesLeft > 0)) {
                  _context4.next = 40;
                  break;
                }
                sharesForPoly = this.shares[this.metadata.polyIDList[z][0]];
                if (!sharesForPoly) {
                  _context4.next = 37;
                  break;
                }
                shareIndexesForPoly = Object.keys(sharesForPoly);
                k = 0;
              case 17:
                if (!(k < shareIndexesForPoly.length && sharesLeft > 0)) {
                  _context4.next = 37;
                  break;
                }
                if (!(shareIndexesForPoly[k] in shareIndexesRequired)) {
                  _context4.next = 34;
                  break;
                }
                currentShareForPoly = sharesForPoly[shareIndexesForPoly[k]];
                if (!(currentShareForPoly.polynomialID === pubPolyID)) {
                  _context4.next = 24;
                  break;
                }
                sharesToInput.push(currentShareForPoly);
                _context4.next = 32;
                break;
              case 24:
                _context4.next = 26;
                return this.catchupToLatestShare({
                  shareStore: currentShareForPoly,
                  polyID: pubPolyID,
                  includeLocalMetadataTransitions: true
                });
              case 26:
                latestShareRes = _context4.sent;
                if (!(latestShareRes.latestShare.polynomialID === pubPolyID)) {
                  _context4.next = 31;
                  break;
                }
                sharesToInput.push(latestShareRes.latestShare);
                _context4.next = 32;
                break;
              case 31:
                throw new errors(1304, "Share found in unexpected polynomial");
              case 32:
                delete shareIndexesRequired[shareIndexesForPoly[k]];
                sharesLeft -= 1;
              case 34:
                k += 1;
                _context4.next = 17;
                break;
              case 37:
                z -= 1;
                _context4.next = 12;
                break;
              case 40:
                // Input shares to ensure atomicity
                sharesToInput.forEach(function (share) {
                  _this.inputShareStore(share);
                });
                if (!(sharesLeft > 0)) {
                  _context4.next = 43;
                  break;
                }
                throw errors.unableToReconstruct(" require ".concat(requiredThreshold, " but have ").concat(requiredThreshold - sharesLeft));
              case 43:
                polyShares = Object.keys(this.shares[pubPolyID]);
                shareArr = [];
                shareIndexArr = [];
                for (_i = 0; _i < requiredThreshold; _i += 1) {
                  shareArr.push(this.shares[pubPolyID][polyShares[_i]].share.share);
                  shareIndexArr.push(this.shares[pubPolyID][polyShares[_i]].share.shareIndex);
                }
                privKey = lagrangeInterpolation(shareArr, shareIndexArr); // check that priv key regenerated is correct
                reconstructedPubKey = (0,common_types_namespaceObject.getPubKeyPoint)(privKey);
                if (!(this.metadata.pubKey.x.cmp(reconstructedPubKey.x) !== 0)) {
                  _context4.next = 51;
                  break;
                }
                throw errors.incorrectReconstruction();
              case 51:
                this._setKey(privKey);
                returnObject = {
                  privKey: privKey,
                  allKeys: [privKey]
                };
                if (!(_reconstructKeyMiddleware && Object.keys(this._reconstructKeyMiddleware).length > 0)) {
                  _context4.next = 56;
                  break;
                }
                _context4.next = 56;
                return Promise.all(Object.keys(this._reconstructKeyMiddleware).map( /*#__PURE__*/function () {
                  var _ref2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee3(x) {
                    var _returnObject$allKeys, extraKeys;
                    return regenerator_default().wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!Object.prototype.hasOwnProperty.call(_this._reconstructKeyMiddleware, x)) {
                              _context3.next = 6;
                              break;
                            }
                            _context3.next = 3;
                            return _this._reconstructKeyMiddleware[x]();
                          case 3:
                            extraKeys = _context3.sent;
                            returnObject[x] = extraKeys;
                            (_returnObject$allKeys = returnObject.allKeys).push.apply(_returnObject$allKeys, toConsumableArray_default()(extraKeys));
                          case 6:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));
                  return function (_x3) {
                    return _ref2.apply(this, arguments);
                  };
                }()));
              case 56:
                return _context4.abrupt("return", returnObject);
              case 57:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
      function reconstructKey() {
        return _reconstructKey.apply(this, arguments);
      }
      return reconstructKey;
    }()
  }, {
    key: "reconstructLatestPoly",
    value: function reconstructLatestPoly() {
      if (!this.metadata) {
        throw errors.metadataUndefined();
      }
      var pubPoly = this.metadata.getLatestPublicPolynomial();
      var pubPolyID = pubPoly.getPolynomialID();
      var threshold = pubPoly.getThreshold();
      var pointsArr = [];
      var sharesForExistingPoly = Object.keys(this.shares[pubPolyID]);
      if (sharesForExistingPoly.length < threshold) {
        throw errors.unableToReconstruct("not enough shares to reconstruct poly");
      }
      if (new Set(sharesForExistingPoly).size !== sharesForExistingPoly.length) {
        throw errors["default"]("share indexes should be unique");
      }
      for (var i = 0; i < threshold; i += 1) {
        pointsArr.push(new common_types_namespaceObject.Point(new (external_bn_js_default())(sharesForExistingPoly[i], "hex"), this.shares[pubPolyID][sharesForExistingPoly[i]].share.share));
      }
      return lagrangeInterpolatePolynomial(pointsArr);
    }
  }, {
    key: "deleteShare",
    value: function () {
      var _deleteShare = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee5(shareIndex) {
        var shareIndexToDelete, shareToDelete, pubPoly, previousPolyID, existingShareIndexes, newShareIndexes, results, newShareStores;
        return regenerator_default().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this.metadata) {
                  _context5.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                if (this.privKey) {
                  _context5.next = 4;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 4:
                shareIndexToDelete = new (external_bn_js_default())(shareIndex, "hex");
                shareToDelete = this.outputShareStore(shareIndexToDelete);
                if (!(shareIndexToDelete.cmp(new (external_bn_js_default())("1", "hex")) === 0)) {
                  _context5.next = 8;
                  break;
                }
                throw new errors(1001, "Unable to delete service provider share");
              case 8:
                // Get existing shares
                pubPoly = this.metadata.getLatestPublicPolynomial();
                previousPolyID = pubPoly.getPolynomialID();
                existingShareIndexes = this.metadata.getShareIndexesForPolynomial(previousPolyID);
                newShareIndexes = [];
                existingShareIndexes.forEach(function (el) {
                  var bn = new (external_bn_js_default())(el, "hex");
                  if (bn.cmp(shareIndexToDelete) !== 0) {
                    newShareIndexes.push(bn.toString("hex"));
                  }
                });

                // Update shares
                if (!(existingShareIndexes.length === newShareIndexes.length)) {
                  _context5.next = 17;
                  break;
                }
                throw errors["default"]("Share index does not exist in latest polynomial");
              case 17:
                if (!(newShareIndexes.length < pubPoly.getThreshold())) {
                  _context5.next = 19;
                  break;
                }
                throw errors["default"]("Minimum ".concat(pubPoly.getThreshold(), " shares are required for tkey. Unable to delete share"));
              case 19:
                _context5.next = 21;
                return this._refreshShares(pubPoly.getThreshold(), [].concat(newShareIndexes), previousPolyID);
              case 21:
                results = _context5.sent;
                newShareStores = results.shareStores;
                _context5.next = 25;
                return this.addLocalMetadataTransitions({
                  input: [{
                    message: common_types_namespaceObject.SHARE_DELETED,
                    dateAdded: Date.now()
                  }],
                  privKey: [shareToDelete.share.share]
                });
              case 25:
                return _context5.abrupt("return", {
                  newShareStores: newShareStores
                });
              case 26:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function deleteShare(_x4) {
        return _deleteShare.apply(this, arguments);
      }
      return deleteShare;
    }()
  }, {
    key: "generateNewShare",
    value: function () {
      var _generateNewShare = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee6() {
        var pubPoly, previousPolyID, existingShareIndexes, existingShareIndexesBN, newShareIndex, results, newShareStores;
        return regenerator_default().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this.metadata) {
                  _context6.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                if (this.privKey) {
                  _context6.next = 4;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 4:
                pubPoly = this.metadata.getLatestPublicPolynomial();
                previousPolyID = pubPoly.getPolynomialID();
                existingShareIndexes = this.metadata.getShareIndexesForPolynomial(previousPolyID);
                existingShareIndexesBN = existingShareIndexes.map(function (el) {
                  return new (external_bn_js_default())(el, "hex");
                });
                newShareIndex = new (external_bn_js_default())((0,common_types_namespaceObject.generatePrivateExcludingIndexes)(existingShareIndexesBN));
                _context6.next = 11;
                return this._refreshShares(pubPoly.getThreshold(), [].concat(toConsumableArray_default()(existingShareIndexes), [newShareIndex.toString("hex")]), previousPolyID);
              case 11:
                results = _context6.sent;
                newShareStores = results.shareStores;
                return _context6.abrupt("return", {
                  newShareStores: newShareStores,
                  newShareIndex: newShareIndex
                });
              case 14:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function generateNewShare() {
        return _generateNewShare.apply(this, arguments);
      }
      return generateNewShare;
    }()
  }, {
    key: "_refreshShares",
    value: function () {
      var _refreshShares2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee8(threshold, newShareIndexes, previousPolyID) {
        var _this2 = this;
        var poly, shares, existingShareIndexes, pointsArr, sharesForExistingPoly, i, oldPoly, shareIndexesNeedingEncryption, index, shareIndexHex, oldShareStores, newShareStores, polyID, m, newScopedStore, sharesToPush, metadataToPush, moduleName, adjustedGeneralStore, newShareMetadataToPush, newShareStoreSharesToPush, AuthMetadatas, _index, shareIndex;
        return regenerator_default().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this.metadata) {
                  _context8.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                if (this.privKey) {
                  _context8.next = 4;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 4:
                if (!(threshold > newShareIndexes.length)) {
                  _context8.next = 6;
                  break;
                }
                throw errors["default"]("threshold should not be greater than share indexes. ".concat(threshold, " > ").concat(newShareIndexes.length));
              case 6:
                // update metadata nonce
                this.metadata.nonce += 1;
                poly = generateRandomPolynomial(threshold - 1, this.privKey);
                shares = poly.generateShares(newShareIndexes);
                existingShareIndexes = this.metadata.getShareIndexesForPolynomial(previousPolyID);
                pointsArr = [];
                sharesForExistingPoly = Object.keys(this.shares[previousPolyID]);
                if (!(sharesForExistingPoly.length < threshold)) {
                  _context8.next = 14;
                  break;
                }
                throw errors.unableToReconstruct("not enough shares for polynomial reconstruction");
              case 14:
                for (i = 0; i < threshold; i += 1) {
                  pointsArr.push(new common_types_namespaceObject.Point(new (external_bn_js_default())(sharesForExistingPoly[i], "hex"), this.shares[previousPolyID][sharesForExistingPoly[i]].share.share));
                }
                oldPoly = lagrangeInterpolatePolynomial(pointsArr);
                shareIndexesNeedingEncryption = [];
                for (index = 0; index < existingShareIndexes.length; index += 1) {
                  shareIndexHex = existingShareIndexes[index]; // define shares that need encryption/relaying
                  if (newShareIndexes.includes(shareIndexHex)) {
                    shareIndexesNeedingEncryption.push(shareIndexHex);
                  }
                }

                // add metadata new poly to metadata
                this.metadata.addFromPolynomialAndShares(poly, shares);

                // change to share stores for public storing
                oldShareStores = {};
                newShareStores = {};
                polyID = poly.getPolynomialID();
                newShareIndexes.forEach(function (shareIndexHex) {
                  newShareStores[shareIndexHex] = new common_types_namespaceObject.ShareStore(shares[shareIndexHex], polyID);
                });

                // evaluate oldPoly for old shares and set new metadata with encrypted share for new polynomial
                m = this.metadata.clone();
                newScopedStore = {};
                _context8.next = 27;
                return Promise.all(shareIndexesNeedingEncryption.map( /*#__PURE__*/function () {
                  var _ref3 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee7(shareIndex) {
                    var oldShare, encryptedShare;
                    return regenerator_default().wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            oldShare = oldPoly.polyEval(new (external_bn_js_default())(shareIndex, "hex"));
                            _context7.next = 3;
                            return (0,common_types_namespaceObject.encrypt)((0,common_types_namespaceObject.getPubKeyECC)(oldShare), Buffer.from(JSON.stringify(newShareStores[shareIndex])));
                          case 3:
                            encryptedShare = _context7.sent;
                            newScopedStore[(0,common_types_namespaceObject.getPubKeyPoint)(oldShare).x.toString("hex")] = encryptedShare;
                            oldShareStores[shareIndex] = new common_types_namespaceObject.ShareStore(new common_types_namespaceObject.Share(shareIndex, oldShare), previousPolyID);
                            return _context7.abrupt("return", oldShare);
                          case 7:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7);
                  }));
                  return function (_x8) {
                    return _ref3.apply(this, arguments);
                  };
                }()));
              case 27:
                sharesToPush = _context8.sent;
                m.setScopedStore("encryptedShares", newScopedStore);
                metadataToPush = Array(sharesToPush.length).fill(m); // run refreshShare middleware
                // If a shareIndex is left out during refresh shares, we assume that it being explicitly deleted.
                for (moduleName in this._refreshMiddleware) {
                  if (Object.prototype.hasOwnProperty.call(this._refreshMiddleware, moduleName)) {
                    adjustedGeneralStore = this._refreshMiddleware[moduleName](this.metadata.getGeneralStoreDomain(moduleName), oldShareStores, newShareStores);
                    if (!adjustedGeneralStore) this.metadata.deleteGeneralStoreDomain(moduleName);else this.metadata.setGeneralStoreDomain(moduleName, adjustedGeneralStore);
                  }
                }
                newShareMetadataToPush = [];
                newShareStoreSharesToPush = newShareIndexes.map(function (shareIndex) {
                  var me = _this2.metadata.clone();
                  newShareMetadataToPush.push(me);
                  return newShareStores[shareIndex].share.share;
                });
                AuthMetadatas = this.generateAuthMetadata({
                  input: [].concat(toConsumableArray_default()(metadataToPush), newShareMetadataToPush)
                }); // Combine Authmetadata and service provider ShareStore
                _context8.next = 36;
                return this.addLocalMetadataTransitions({
                  input: [].concat(toConsumableArray_default()(AuthMetadatas), [newShareStores["1"]]),
                  privKey: [].concat(toConsumableArray_default()(sharesToPush), toConsumableArray_default()(newShareStoreSharesToPush), [undefined])
                });
              case 36:
                // update this.shares with these new shares
                for (_index = 0; _index < newShareIndexes.length; _index += 1) {
                  shareIndex = newShareIndexes[_index];
                  this.inputShareStore(newShareStores[shareIndex]);
                }
                // await this.releaseWriteMetadataLock();
                return _context8.abrupt("return", {
                  shareStores: newShareStores
                });
              case 38:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function _refreshShares(_x5, _x6, _x7) {
        return _refreshShares2.apply(this, arguments);
      }
      return _refreshShares;
    }()
  }, {
    key: "_initializeNewKey",
    value: function () {
      var _initializeNewKey2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee9() {
        var _this3 = this;
        var _ref4,
          determinedShare,
          initializeModules,
          importedKey,
          delete1OutOf1,
          tmpPriv,
          shareIndexForDeviceStorage,
          shareIndexes,
          poly,
          shareIndexForDeterminedShare,
          shares,
          metadata,
          serviceProviderShare,
          shareStore,
          metadataToPush,
          sharesToPush,
          authMetadatas,
          index,
          shareIndex,
          result,
          _args9 = arguments;
        return regenerator_default().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _ref4 = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : {}, determinedShare = _ref4.determinedShare, initializeModules = _ref4.initializeModules, importedKey = _ref4.importedKey, delete1OutOf1 = _ref4.delete1OutOf1;
                if (!importedKey) {
                  tmpPriv = (0,eccrypto_namespaceObject.generatePrivate)();
                  this._setKey(new (external_bn_js_default())(tmpPriv));
                } else {
                  this._setKey(new (external_bn_js_default())(importedKey));
                }

                // create a random poly and respective shares
                // 1 is defined as the serviceProvider share
                // 0 is for tKey
                shareIndexForDeviceStorage = (0,common_types_namespaceObject.generatePrivateExcludingIndexes)([new (external_bn_js_default())(1), new (external_bn_js_default())(0)]);
                shareIndexes = [new (external_bn_js_default())(1), shareIndexForDeviceStorage];
                if (determinedShare) {
                  shareIndexForDeterminedShare = (0,common_types_namespaceObject.generatePrivateExcludingIndexes)([new (external_bn_js_default())(1), new (external_bn_js_default())(0)]);
                  poly = generateRandomPolynomial(1, this.privKey, [new common_types_namespaceObject.Share(shareIndexForDeterminedShare, determinedShare)]);
                  shareIndexes.push(shareIndexForDeterminedShare);
                } else {
                  poly = generateRandomPolynomial(1, this.privKey);
                }
                shares = poly.generateShares(shareIndexes); // create metadata to be stored
                metadata = new src_metadata((0,common_types_namespaceObject.getPubKeyPoint)(this.privKey));
                metadata.addFromPolynomialAndShares(poly, shares);
                serviceProviderShare = shares[shareIndexes[0].toString("hex")];
                shareStore = new common_types_namespaceObject.ShareStore(serviceProviderShare, poly.getPolynomialID());
                this.metadata = metadata;

                // initialize modules
                if (!initializeModules) {
                  _context9.next = 14;
                  break;
                }
                _context9.next = 14;
                return this.initializeModules();
              case 14:
                metadataToPush = [];
                sharesToPush = shareIndexes.map(function (shareIndex) {
                  metadataToPush.push(_this3.metadata);
                  return shares[shareIndex.toString("hex")].share;
                });
                authMetadatas = this.generateAuthMetadata({
                  input: metadataToPush
                }); // because this is the first time we're setting metadata there is no need to acquire a lock
                // acquireLock: false. Force push
                _context9.next = 19;
                return this.addLocalMetadataTransitions({
                  input: [].concat(toConsumableArray_default()(authMetadatas), [shareStore]),
                  privKey: [].concat(toConsumableArray_default()(sharesToPush), [undefined])
                });
              case 19:
                if (!delete1OutOf1) {
                  _context9.next = 22;
                  break;
                }
                _context9.next = 22;
                return this.addLocalMetadataTransitions({
                  input: [{
                    message: common_types_namespaceObject.ONE_KEY_DELETE_NONCE
                  }],
                  privKey: [this.serviceProvider.postboxKey]
                });
              case 22:
                // store metadata on metadata respective to shares
                for (index = 0; index < shareIndexes.length; index += 1) {
                  shareIndex = shareIndexes[index]; // also add into our share store
                  this.inputShareStore(new common_types_namespaceObject.ShareStore(shares[shareIndex.toString("hex")], poly.getPolynomialID()));
                }
                if (!this.storeDeviceShare) {
                  _context9.next = 26;
                  break;
                }
                _context9.next = 26;
                return this.storeDeviceShare(new common_types_namespaceObject.ShareStore(shares[shareIndexes[1].toString("hex")], poly.getPolynomialID()));
              case 26:
                result = {
                  privKey: this.privKey,
                  deviceShare: new common_types_namespaceObject.ShareStore(shares[shareIndexes[1].toString("hex")], poly.getPolynomialID()),
                  userShare: undefined
                };
                if (determinedShare) {
                  result.userShare = new common_types_namespaceObject.ShareStore(shares[shareIndexes[2].toString("hex")], poly.getPolynomialID());
                }
                return _context9.abrupt("return", result);
              case 29:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));
      function _initializeNewKey() {
        return _initializeNewKey2.apply(this, arguments);
      }
      return _initializeNewKey;
    }()
  }, {
    key: "addLocalMetadataTransitions",
    value: function () {
      var _addLocalMetadataTransitions = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee10(params) {
        var privKey, input;
        return regenerator_default().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                privKey = params.privKey, input = params.input;
                this._localMetadataTransitions[0] = [].concat(toConsumableArray_default()(this._localMetadataTransitions[0]), toConsumableArray_default()(privKey));
                this._localMetadataTransitions[1] = [].concat(toConsumableArray_default()(this._localMetadataTransitions[1]), toConsumableArray_default()(input));
                if (this.manualSync) {
                  _context10.next = 6;
                  break;
                }
                _context10.next = 6;
                return this.syncLocalMetadataTransitions();
              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));
      function addLocalMetadataTransitions(_x9) {
        return _addLocalMetadataTransitions.apply(this, arguments);
      }
      return addLocalMetadataTransitions;
    }()
  }, {
    key: "syncLocalMetadataTransitions",
    value: function () {
      var _syncLocalMetadataTransitions = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee11() {
        var acquiredLock;
        return regenerator_default().wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (this.metadata) {
                  _context11.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                if (Array.isArray(this._localMetadataTransitions[0]) && this._localMetadataTransitions[0].length > 0) {
                  _context11.next = 4;
                  break;
                }
                return _context11.abrupt("return");
              case 4:
                // get lock
                acquiredLock = false;
                if (!this.lastFetchedCloudMetadata) {
                  _context11.next = 9;
                  break;
                }
                _context11.next = 8;
                return this.acquireWriteMetadataLock();
              case 8:
                acquiredLock = true;
              case 9:
                _context11.prev = 9;
                _context11.next = 12;
                return this.storageLayer.setMetadataStream({
                  input: this._localMetadataTransitions[1],
                  privKey: this._localMetadataTransitions[0],
                  serviceProvider: this.serviceProvider
                });
              case 12:
                _context11.next = 17;
                break;
              case 14:
                _context11.prev = 14;
                _context11.t0 = _context11["catch"](9);
                throw errors.metadataPostFailed((0,common_types_namespaceObject.prettyPrintError)(_context11.t0));
              case 17:
                this._localMetadataTransitions = [[], []];
                this.lastFetchedCloudMetadata = this.metadata.clone();
                // release lock
                if (!acquiredLock) {
                  _context11.next = 22;
                  break;
                }
                _context11.next = 22;
                return this.releaseWriteMetadataLock();
              case 22:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[9, 14]]);
      }));
      function syncLocalMetadataTransitions() {
        return _syncLocalMetadataTransitions.apply(this, arguments);
      }
      return syncLocalMetadataTransitions;
    }() // Returns a new instance of metadata with a clean state. All the previous state will be reset.
  }, {
    key: "updateSDK",
    value: function () {
      var _updateSDK = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee12(params) {
        var _this4 = this;
        var tb, allPolyIDList, lastValidPolyID, shareStoresForLastValidPolyID;
        return regenerator_default().wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                tb = new ThresholdKey({
                  enableLogging: this.enableLogging,
                  modules: this.modules,
                  serviceProvider: this.serviceProvider,
                  storageLayer: this.storageLayer,
                  manualSync: this.manualSync
                });
                _context12.prev = 1;
                _context12.next = 4;
                return tb.initialize({
                  neverInitializeNewKey: true,
                  withShare: params && params.withShare
                });
              case 4:
                _context12.next = 9;
                break;
              case 6:
                _context12.prev = 6;
                _context12.t0 = _context12["catch"](1);
                throw errors.fromCode(1103, "".concat(_context12.t0.message));
              case 9:
                // Delete unnecessary polyIDs and shareStores
                allPolyIDList = tb.metadata.polyIDList;
                Object.keys(this.shares).forEach(function (x) {
                  if (allPolyIDList.find(function (id) {
                    return id[0] === x;
                  })) {
                    lastValidPolyID = x;
                  } else {
                    delete _this4.shares[x];
                  }
                });

                // catchup to latest shareStore for all latest available shares.
                // TODO: fix edge cases where shares are deleted in the newer polynomials
                // TODO: maybe assign this.shares directly rather than output and inputsharestore.
                shareStoresForLastValidPolyID = Object.keys(this.shares[lastValidPolyID]).map(function (x) {
                  return tb.inputShareStoreSafe(_this4.outputShareStore(x, lastValidPolyID));
                });
                _context12.next = 14;
                return Promise.all(shareStoresForLastValidPolyID);
              case 14:
                return _context12.abrupt("return", tb);
              case 15:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[1, 6]]);
      }));
      function updateSDK(_x10) {
        return _updateSDK.apply(this, arguments);
      }
      return updateSDK;
    }() // NOTE: This API will be DEPRECATED in the future in favour of inputShareStoreSafe()
  }, {
    key: "inputShareStore",
    value: function inputShareStore(shareStore) {
      var ss;
      if (shareStore instanceof common_types_namespaceObject.ShareStore) {
        ss = shareStore;
      } else if (typeof_default()(shareStore) === "object") {
        ss = common_types_namespaceObject.ShareStore.fromJSON(shareStore);
      } else {
        throw errors["default"]("can only add type ShareStore into shares");
      }
      if (!(ss.polynomialID in this.shares)) {
        this.shares[ss.polynomialID] = {};
      }
      this.shares[ss.polynomialID][ss.share.shareIndex.toString("hex")] = ss;
    }

    // inputs a share ensuring that the share is the latest share AND metadata is updated to its latest state
  }, {
    key: "inputShareStoreSafe",
    value: function () {
      var _inputShareStoreSafe = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee13(shareStore) {
        var autoUpdateMetadata,
          ss,
          latestShareRes,
          _args13 = arguments;
        return regenerator_default().wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                autoUpdateMetadata = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : false;
                if (this.metadata) {
                  _context13.next = 3;
                  break;
                }
                throw errors.metadataUndefined();
              case 3:
                if (!(shareStore instanceof common_types_namespaceObject.ShareStore)) {
                  _context13.next = 7;
                  break;
                }
                ss = shareStore;
                _context13.next = 12;
                break;
              case 7:
                if (!(typeof_default()(shareStore) === "object")) {
                  _context13.next = 11;
                  break;
                }
                ss = common_types_namespaceObject.ShareStore.fromJSON(shareStore);
                _context13.next = 12;
                break;
              case 11:
                throw errors["default"]("can only add type ShareStore into shares");
              case 12:
                _context13.next = 14;
                return this.catchupToLatestShare({
                  shareStore: ss,
                  includeLocalMetadataTransitions: true
                });
              case 14:
                latestShareRes = _context13.sent;
                if (this.metadata.polyIDList.find(function (tuple) {
                  return tuple[0] === latestShareRes.latestShare.polynomialID;
                })) {
                  _context13.next = 21;
                  break;
                }
                if (autoUpdateMetadata) {
                  _context13.next = 20;
                  break;
                }
                throw errors["default"]("TKey SDK metadata seems to be outdated because shareIndex: " + "".concat(latestShareRes.latestShare.share.shareIndex.toString("hex"), " has a more recent metadata. Please call updateSDK first"));
              case 20:
                this.metadata = latestShareRes.shareMetadata;
              case 21:
                if (!(latestShareRes.latestShare.polynomialID in this.shares)) {
                  this.shares[latestShareRes.latestShare.polynomialID] = {};
                }
                this.shares[latestShareRes.latestShare.polynomialID][latestShareRes.latestShare.share.shareIndex.toString("hex")] = latestShareRes.latestShare;
              case 23:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));
      function inputShareStoreSafe(_x11) {
        return _inputShareStoreSafe.apply(this, arguments);
      }
      return inputShareStoreSafe;
    }()
  }, {
    key: "outputShareStore",
    value: function outputShareStore(shareIndex, polyID) {
      if (!this.metadata) {
        throw errors.metadataUndefined();
      }
      var shareIndexParsed;
      if (typeof shareIndex === "number") {
        shareIndexParsed = new (external_bn_js_default())(shareIndex);
      } else if (external_bn_js_default().isBN(shareIndex)) {
        shareIndexParsed = shareIndex;
      } else if (typeof shareIndex === "string") {
        shareIndexParsed = new (external_bn_js_default())(shareIndex, "hex");
      }
      var polyIDToSearch;
      if (polyID) {
        polyIDToSearch = polyID;
      } else {
        polyIDToSearch = this.metadata.getLatestPublicPolynomial().getPolynomialID();
      }
      if (!this.metadata.getShareIndexesForPolynomial(polyIDToSearch).includes(shareIndexParsed.toString("hex"))) {
        throw new errors(1002, "no such share index created");
      }
      var shareFromStore = this.shares[polyIDToSearch][shareIndexParsed.toString("hex")];
      if (shareFromStore) return shareFromStore;
      var poly = this.reconstructLatestPoly();
      var shareMap = poly.generateShares([shareIndexParsed]);
      return new common_types_namespaceObject.ShareStore(shareMap[shareIndexParsed.toString("hex")], polyIDToSearch);
    }
  }, {
    key: "_setKey",
    value: function _setKey(privKey) {
      this.privKey = privKey;
    }
  }, {
    key: "getCurrentShareIndexes",
    value: function getCurrentShareIndexes() {
      if (!this.metadata) {
        throw errors.metadataUndefined();
      }
      var latestPolynomial = this.metadata.getLatestPublicPolynomial();
      var latestPolynomialId = latestPolynomial.getPolynomialID();
      var currentShareIndexes = Object.keys(this.shares[latestPolynomialId]);
      return currentShareIndexes;
    }
  }, {
    key: "getKeyDetails",
    value: function getKeyDetails() {
      if (!this.metadata) {
        throw errors.metadataUndefined();
      }
      var poly = this.metadata.getLatestPublicPolynomial();
      var previousPolyID = poly.getPolynomialID();
      var requiredShares = poly.getThreshold() - Object.keys(this.shares[previousPolyID]).length;
      var shareDescriptions = this.metadata.getShareDescription();
      if (shareDescriptions) {
        var existingShareIndexes = this.metadata.getShareIndexesForPolynomial(previousPolyID);
        shareDescriptions = Object.keys(shareDescriptions).reduce(function (acc, index) {
          if (existingShareIndexes.indexOf(index) >= 0) acc[index] = shareDescriptions[index];
          return acc;
        }, {});
      }
      return {
        pubKey: this.metadata.pubKey,
        requiredShares: requiredShares,
        threshold: poly.getThreshold(),
        totalShares: this.metadata.getShareIndexesForPolynomial(previousPolyID).length,
        shareDescriptions: shareDescriptions
      };
    }

    // Auth functions
  }, {
    key: "generateAuthMetadata",
    value: function generateAuthMetadata(params) {
      var input = params.input;
      var authMetadatas = [];
      for (var i = 0; i < input.length; i += 1) {
        authMetadatas.push(new src_authMetadata(input[i], this.privKey));
      }
      return authMetadatas;
    }
  }, {
    key: "setAuthMetadata",
    value: function setAuthMetadata(params) {
      var input = params.input,
        serviceProvider = params.serviceProvider,
        privKey = params.privKey;
      var authMetadata = new src_authMetadata(input, this.privKey);
      return this.storageLayer.setMetadata({
        input: authMetadata,
        serviceProvider: serviceProvider,
        privKey: privKey
      });
    }
  }, {
    key: "setAuthMetadataBulk",
    value: function () {
      var _setAuthMetadataBulk = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee14(params) {
        var input, serviceProvider, privKey, authMetadatas, i;
        return regenerator_default().wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (this.privKey) {
                  _context14.next = 2;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 2:
                input = params.input, serviceProvider = params.serviceProvider, privKey = params.privKey;
                authMetadatas = [];
                for (i = 0; i < input.length; i += 1) {
                  authMetadatas.push(new src_authMetadata(input[i], this.privKey));
                }
                _context14.next = 7;
                return this.addLocalMetadataTransitions({
                  input: authMetadatas,
                  serviceProvider: serviceProvider,
                  privKey: privKey
                });
              case 7:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));
      function setAuthMetadataBulk(_x12) {
        return _setAuthMetadataBulk.apply(this, arguments);
      }
      return setAuthMetadataBulk;
    }()
  }, {
    key: "getAuthMetadata",
    value: function () {
      var _getAuthMetadata = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee15(params) {
        var raw, authMetadata;
        return regenerator_default().wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.getGenericMetadataWithTransitionStates(_objectSpread(_objectSpread({}, params), {}, {
                  fromJSONConstructor: src_authMetadata
                }));
              case 2:
                raw = _context15.sent;
                authMetadata = raw;
                return _context15.abrupt("return", authMetadata.metadata);
              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));
      function getAuthMetadata(_x13) {
        return _getAuthMetadata.apply(this, arguments);
      }
      return getAuthMetadata;
    }() // fetches the latest metadata potentially searching in local transition states first
  }, {
    key: "getGenericMetadataWithTransitionStates",
    value: function () {
      var _getGenericMetadataWithTransitionStates = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee16(params) {
        var transitions, index, i, x, raw;
        return regenerator_default().wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (params.serviceProvider && params.serviceProvider.postboxKey.toString("hex") !== "0" || params.privKey) {
                  _context16.next = 2;
                  break;
                }
                throw errors["default"]("require either serviceProvider or priv key in getGenericMetadataWithTransitionStates");
              case 2:
                if (!params.includeLocalMetadataTransitions) {
                  _context16.next = 8;
                  break;
                }
                transitions = params._localMetadataTransitions ? params._localMetadataTransitions : this._localMetadataTransitions;
                index = null;
                for (i = transitions[0].length - 1; i >= 0; i -= 1) {
                  x = transitions[0][i];
                  if (params.privKey && x && x.cmp(params.privKey) === 0) index = i;else if (params.serviceProvider && !x) index = i;
                }
                if (!(index !== null)) {
                  _context16.next = 8;
                  break;
                }
                return _context16.abrupt("return", transitions[1][index]);
              case 8:
                _context16.prev = 8;
                _context16.next = 11;
                return this.storageLayer.getMetadata(params);
              case 11:
                raw = _context16.sent;
                _context16.next = 17;
                break;
              case 14:
                _context16.prev = 14;
                _context16.t0 = _context16["catch"](8);
                throw errors.metadataGetFailed("".concat((0,common_types_namespaceObject.prettyPrintError)(_context16.t0)));
              case 17:
                if (!(raw.message === common_types_namespaceObject.SHARE_DELETED)) {
                  _context16.next = 19;
                  break;
                }
                throw errors.fromCode(1308);
              case 19:
                return _context16.abrupt("return", params.fromJSONConstructor.fromJSON(raw));
              case 20:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[8, 14]]);
      }));
      function getGenericMetadataWithTransitionStates(_x14) {
        return _getGenericMetadataWithTransitionStates.apply(this, arguments);
      }
      return getGenericMetadataWithTransitionStates;
    }() // Lock functions
  }, {
    key: "acquireWriteMetadataLock",
    value: function () {
      var _acquireWriteMetadataLock = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee17() {
        var randomShareStore, latestPolyIDOnCloud, shareIndexesExistInSDK, randomIndex, latestRes, latestMetadata, res;
        return regenerator_default().wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!this.haveWriteMetadataLock) {
                  _context17.next = 2;
                  break;
                }
                return _context17.abrupt("return", this.metadata.nonce);
              case 2:
                if (this.privKey) {
                  _context17.next = 4;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 4:
                latestPolyIDOnCloud = this.lastFetchedCloudMetadata.getLatestPublicPolynomial().getPolynomialID();
                shareIndexesExistInSDK = Object.keys(this.shares[latestPolyIDOnCloud]);
                randomIndex = shareIndexesExistInSDK[Math.floor(Math.random() * (shareIndexesExistInSDK.length - 1))];
                if (shareIndexesExistInSDK.length >= 1) {
                  randomShareStore = this.shares[latestPolyIDOnCloud][randomIndex];
                } else {
                  randomShareStore = this.outputShareStore(randomIndex, latestPolyIDOnCloud);
                }
                _context17.next = 10;
                return this.catchupToLatestShare({
                  shareStore: randomShareStore
                });
              case 10:
                latestRes = _context17.sent;
                latestMetadata = latestRes.shareMetadata; // read errors for what each means
                if (!(latestMetadata.nonce > this.lastFetchedCloudMetadata.nonce)) {
                  _context17.next = 16;
                  break;
                }
                throw errors.acquireLockFailed("unable to acquire write access for metadata due to \n      lastFetchedCloudMetadata (".concat(this.lastFetchedCloudMetadata.nonce, ")\n           being lower than last written metadata nonce (").concat(latestMetadata.nonce, "). perhaps update metadata SDK (create new tKey and init)"));
              case 16:
                if (!(latestMetadata.nonce < this.lastFetchedCloudMetadata.nonce)) {
                  _context17.next = 18;
                  break;
                }
                throw errors.acquireLockFailed("unable to acquire write access for metadata due to \n      lastFetchedCloudMetadata (".concat(this.lastFetchedCloudMetadata.nonce, ")\n      being higher than last written metadata nonce (").concat(latestMetadata.nonce, "). this should never happen as it \n      should only ever be updated by getting metadata)"));
              case 18:
                _context17.next = 20;
                return this.storageLayer.acquireWriteLock({
                  privKey: this.privKey
                });
              case 20:
                res = _context17.sent;
                if (!(res.status !== 1)) {
                  _context17.next = 23;
                  break;
                }
                throw errors.acquireLockFailed("lock cannot be acquired from storage layer status code: ".concat(res.status));
              case 23:
                // increment metadata nonce for write session
                // this.metadata.nonce += 1;
                this.haveWriteMetadataLock = res.id;
                return _context17.abrupt("return", this.metadata.nonce);
              case 25:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));
      function acquireWriteMetadataLock() {
        return _acquireWriteMetadataLock.apply(this, arguments);
      }
      return acquireWriteMetadataLock;
    }()
  }, {
    key: "releaseWriteMetadataLock",
    value: function () {
      var _releaseWriteMetadataLock = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee18() {
        var res;
        return regenerator_default().wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (this.haveWriteMetadataLock) {
                  _context18.next = 2;
                  break;
                }
                throw errors.releaseLockFailed("releaseWriteMetadataLock - don't have metadata lock to release");
              case 2:
                _context18.next = 4;
                return this.storageLayer.releaseWriteLock({
                  privKey: this.privKey,
                  id: this.haveWriteMetadataLock
                });
              case 4:
                res = _context18.sent;
                if (!(res.status !== 1)) {
                  _context18.next = 7;
                  break;
                }
                throw errors.releaseLockFailed("lock cannot be released from storage layer status code: ".concat(res.status));
              case 7:
                this.haveWriteMetadataLock = "";
              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));
      function releaseWriteMetadataLock() {
        return _releaseWriteMetadataLock.apply(this, arguments);
      }
      return releaseWriteMetadataLock;
    }() // Module functions
  }, {
    key: "_syncShareMetadata",
    value: function () {
      var _syncShareMetadata2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee19(adjustScopedStore) {
        var shareArray;
        return regenerator_default().wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (this.metadata) {
                  _context19.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                shareArray = this.getAllShareStoresForLatestPolynomial().map(function (x) {
                  return x.share.share;
                });
                _context19.next = 5;
                return this.syncMultipleShareMetadata(shareArray, adjustScopedStore);
              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));
      function _syncShareMetadata(_x15) {
        return _syncShareMetadata2.apply(this, arguments);
      }
      return _syncShareMetadata;
    }()
  }, {
    key: "syncMultipleShareMetadata",
    value: function () {
      var _syncMultipleShareMetadata = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee21(shares, adjustScopedStore) {
        var _this5 = this;
        var newMetadataPromise, newMetadata;
        return regenerator_default().wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (this.metadata) {
                  _context21.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                this.metadata.nonce += 1;
                newMetadataPromise = shares.map( /*#__PURE__*/function () {
                  var _ref5 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee20(share) {
                    var newMetadata, specificShareMetadata, scopedStoreToBeSet;
                    return regenerator_default().wrap(function _callee20$(_context20) {
                      while (1) {
                        switch (_context20.prev = _context20.next) {
                          case 0:
                            newMetadata = _this5.metadata.clone();
                            _context20.prev = 1;
                            _context20.next = 4;
                            return _this5.getAuthMetadata({
                              privKey: share,
                              includeLocalMetadataTransitions: true
                            });
                          case 4:
                            specificShareMetadata = _context20.sent;
                            _context20.next = 10;
                            break;
                          case 7:
                            _context20.prev = 7;
                            _context20.t0 = _context20["catch"](1);
                            throw errors.authMetadataGetUnavailable("".concat((0,common_types_namespaceObject.prettyPrintError)(_context20.t0)));
                          case 10:
                            if (adjustScopedStore) {
                              scopedStoreToBeSet = adjustScopedStore(specificShareMetadata.scopedStore);
                            } else {
                              scopedStoreToBeSet = specificShareMetadata.scopedStore;
                            }
                            newMetadata.scopedStore = scopedStoreToBeSet;
                            return _context20.abrupt("return", newMetadata);
                          case 13:
                          case "end":
                            return _context20.stop();
                        }
                      }
                    }, _callee20, null, [[1, 7]]);
                  }));
                  return function (_x18) {
                    return _ref5.apply(this, arguments);
                  };
                }());
                _context21.next = 6;
                return Promise.all(newMetadataPromise);
              case 6:
                newMetadata = _context21.sent;
                return _context21.abrupt("return", this.setAuthMetadataBulk({
                  input: newMetadata,
                  privKey: shares
                }));
              case 8:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));
      function syncMultipleShareMetadata(_x16, _x17) {
        return _syncMultipleShareMetadata.apply(this, arguments);
      }
      return syncMultipleShareMetadata;
    }()
  }, {
    key: "_addRefreshMiddleware",
    value: function _addRefreshMiddleware(moduleName, middleware) {
      this._refreshMiddleware[moduleName] = middleware;
    }
  }, {
    key: "_addReconstructKeyMiddleware",
    value: function _addReconstructKeyMiddleware(moduleName, middleware) {
      this._reconstructKeyMiddleware[moduleName] = middleware;
    }
  }, {
    key: "_addShareSerializationMiddleware",
    value: function _addShareSerializationMiddleware(serialize, deserialize) {
      this._shareSerializationMiddleware = {
        serialize: serialize,
        deserialize: deserialize
      };
    }
  }, {
    key: "_setDeviceStorage",
    value: function _setDeviceStorage(storeDeviceStorage) {
      if (this.storeDeviceShare) {
        throw errors["default"]("storeDeviceShare already set");
      }
      this.storeDeviceShare = storeDeviceStorage;
    }
  }, {
    key: "addShareDescription",
    value: function () {
      var _addShareDescription = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee22(shareIndex, description, updateMetadata) {
        return regenerator_default().wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                if (this.metadata) {
                  _context22.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                this.metadata.addShareDescription(shareIndex, description);
                if (!updateMetadata) {
                  _context22.next = 6;
                  break;
                }
                _context22.next = 6;
                return this._syncShareMetadata();
              case 6:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));
      function addShareDescription(_x19, _x20, _x21) {
        return _addShareDescription.apply(this, arguments);
      }
      return addShareDescription;
    }()
  }, {
    key: "deleteShareDescription",
    value: function () {
      var _deleteShareDescription = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee23(shareIndex, description, updateMetadata) {
        return regenerator_default().wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (this.metadata) {
                  _context23.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                this.metadata.deleteShareDescription(shareIndex, description);
                if (!updateMetadata) {
                  _context23.next = 6;
                  break;
                }
                _context23.next = 6;
                return this._syncShareMetadata();
              case 6:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));
      function deleteShareDescription(_x22, _x23, _x24) {
        return _deleteShareDescription.apply(this, arguments);
      }
      return deleteShareDescription;
    }()
  }, {
    key: "updateShareDescription",
    value: function () {
      var _updateShareDescription = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee24(shareIndex, oldDescription, newDescription, updateMetadata) {
        return regenerator_default().wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                if (this.metadata) {
                  _context24.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                this.metadata.updateShareDescription(shareIndex, oldDescription, newDescription);
                if (!updateMetadata) {
                  _context24.next = 6;
                  break;
                }
                _context24.next = 6;
                return this._syncShareMetadata();
              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));
      function updateShareDescription(_x25, _x26, _x27, _x28) {
        return _updateShareDescription.apply(this, arguments);
      }
      return updateShareDescription;
    }()
  }, {
    key: "encrypt",
    value: function () {
      var _encrypt2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee25(data) {
        return regenerator_default().wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (this.privKey) {
                  _context25.next = 2;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 2:
                return _context25.abrupt("return", (0,common_types_namespaceObject.encrypt)((0,common_types_namespaceObject.getPubKeyECC)(this.privKey), data));
              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));
      function encrypt(_x29) {
        return _encrypt2.apply(this, arguments);
      }
      return encrypt;
    }()
  }, {
    key: "decrypt",
    value: function () {
      var _decrypt2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee26(encryptedMessage) {
        return regenerator_default().wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                if (this.privKey) {
                  _context26.next = 2;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 2:
                return _context26.abrupt("return", (0,common_types_namespaceObject.decrypt)((0,common_types_namespaceObject.toPrivKeyECC)(this.privKey), encryptedMessage));
              case 3:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));
      function decrypt(_x30) {
        return _decrypt2.apply(this, arguments);
      }
      return decrypt;
    }()
  }, {
    key: "_setTKeyStoreItem",
    value: function () {
      var _setTKeyStoreItem2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee28(moduleName, data) {
        var _this6 = this;
        var rawTkeyStoreItems, decryptedItems, encryptedData, duplicateItemIndex;
        return regenerator_default().wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                if (this.metadata) {
                  _context28.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                rawTkeyStoreItems = this.metadata.getTkeyStoreDomain(moduleName) || [];
                _context28.next = 5;
                return Promise.all(rawTkeyStoreItems.map( /*#__PURE__*/function () {
                  var _ref6 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee27(x) {
                    var decryptedItem;
                    return regenerator_default().wrap(function _callee27$(_context27) {
                      while (1) {
                        switch (_context27.prev = _context27.next) {
                          case 0:
                            _context27.next = 2;
                            return _this6.decrypt(x);
                          case 2:
                            decryptedItem = _context27.sent;
                            return _context27.abrupt("return", JSON.parse(decryptedItem.toString()));
                          case 4:
                          case "end":
                            return _context27.stop();
                        }
                      }
                    }, _callee27);
                  }));
                  return function (_x33) {
                    return _ref6.apply(this, arguments);
                  };
                }()));
              case 5:
                decryptedItems = _context28.sent;
                _context28.next = 8;
                return this.encrypt(Buffer.from(external_json_stable_stringify_default()(data)));
              case 8:
                encryptedData = _context28.sent;
                duplicateItemIndex = decryptedItems.findIndex(function (x) {
                  return x.id === data.id;
                });
                if (duplicateItemIndex > -1) {
                  rawTkeyStoreItems[duplicateItemIndex] = encryptedData;
                } else {
                  rawTkeyStoreItems.push(encryptedData);
                }

                // update metadataStore
                this.metadata.setTkeyStoreDomain(moduleName, rawTkeyStoreItems);
                _context28.next = 14;
                return this._syncShareMetadata();
              case 14:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));
      function _setTKeyStoreItem(_x31, _x32) {
        return _setTKeyStoreItem2.apply(this, arguments);
      }
      return _setTKeyStoreItem;
    }()
  }, {
    key: "_deleteTKeyStoreItem",
    value: function () {
      var _deleteTKeyStoreItem2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee30(moduleName, id) {
        var _this7 = this;
        var rawTkeyStoreItems, decryptedItems, finalItems;
        return regenerator_default().wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                if (this.metadata) {
                  _context30.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                rawTkeyStoreItems = this.metadata.getTkeyStoreDomain(moduleName) || [];
                _context30.next = 5;
                return Promise.all(rawTkeyStoreItems.map( /*#__PURE__*/function () {
                  var _ref7 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee29(x) {
                    var decryptedItem;
                    return regenerator_default().wrap(function _callee29$(_context29) {
                      while (1) {
                        switch (_context29.prev = _context29.next) {
                          case 0:
                            _context29.next = 2;
                            return _this7.decrypt(x);
                          case 2:
                            decryptedItem = _context29.sent;
                            return _context29.abrupt("return", JSON.parse(decryptedItem.toString()));
                          case 4:
                          case "end":
                            return _context29.stop();
                        }
                      }
                    }, _callee29);
                  }));
                  return function (_x36) {
                    return _ref7.apply(this, arguments);
                  };
                }()));
              case 5:
                decryptedItems = _context30.sent;
                finalItems = decryptedItems.filter(function (x) {
                  return x.id !== id;
                });
                this.metadata.setTkeyStoreDomain(moduleName, finalItems);
                _context30.next = 10;
                return this._syncShareMetadata();
              case 10:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));
      function _deleteTKeyStoreItem(_x34, _x35) {
        return _deleteTKeyStoreItem2.apply(this, arguments);
      }
      return _deleteTKeyStoreItem;
    }()
  }, {
    key: "getTKeyStore",
    value: function () {
      var _getTKeyStore = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee32(moduleName) {
        var _this8 = this;
        var rawTkeyStoreItems, decryptedItems;
        return regenerator_default().wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                if (this.metadata) {
                  _context32.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                rawTkeyStoreItems = this.metadata.getTkeyStoreDomain(moduleName) || [];
                _context32.next = 5;
                return Promise.all(rawTkeyStoreItems.map( /*#__PURE__*/function () {
                  var _ref8 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee31(x) {
                    var decryptedItem;
                    return regenerator_default().wrap(function _callee31$(_context31) {
                      while (1) {
                        switch (_context31.prev = _context31.next) {
                          case 0:
                            _context31.next = 2;
                            return _this8.decrypt(x);
                          case 2:
                            decryptedItem = _context31.sent;
                            return _context31.abrupt("return", JSON.parse(decryptedItem.toString()));
                          case 4:
                          case "end":
                            return _context31.stop();
                        }
                      }
                    }, _callee31);
                  }));
                  return function (_x38) {
                    return _ref8.apply(this, arguments);
                  };
                }()));
              case 5:
                decryptedItems = _context32.sent;
                return _context32.abrupt("return", decryptedItems);
              case 7:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));
      function getTKeyStore(_x37) {
        return _getTKeyStore.apply(this, arguments);
      }
      return getTKeyStore;
    }()
  }, {
    key: "getTKeyStoreItem",
    value: function () {
      var _getTKeyStoreItem = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee34(moduleName, id) {
        var _this9 = this;
        var rawTkeyStoreItems, decryptedItems, item;
        return regenerator_default().wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                if (this.metadata) {
                  _context34.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                rawTkeyStoreItems = this.metadata.getTkeyStoreDomain(moduleName) || [];
                _context34.next = 5;
                return Promise.all(rawTkeyStoreItems.map( /*#__PURE__*/function () {
                  var _ref9 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee33(x) {
                    var decryptedItem;
                    return regenerator_default().wrap(function _callee33$(_context33) {
                      while (1) {
                        switch (_context33.prev = _context33.next) {
                          case 0:
                            _context33.next = 2;
                            return _this9.decrypt(x);
                          case 2:
                            decryptedItem = _context33.sent;
                            return _context33.abrupt("return", JSON.parse(decryptedItem.toString()));
                          case 4:
                          case "end":
                            return _context33.stop();
                        }
                      }
                    }, _callee33);
                  }));
                  return function (_x41) {
                    return _ref9.apply(this, arguments);
                  };
                }()));
              case 5:
                decryptedItems = _context34.sent;
                item = decryptedItems.find(function (x) {
                  return x.id === id;
                });
                return _context34.abrupt("return", item);
              case 8:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));
      function getTKeyStoreItem(_x39, _x40) {
        return _getTKeyStoreItem.apply(this, arguments);
      }
      return getTKeyStoreItem;
    }() // Import export shares
  }, {
    key: "outputShare",
    value: function () {
      var _outputShare = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee35(shareIndex, type) {
        var share;
        return regenerator_default().wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                share = this.outputShareStore(shareIndex).share.share;
                if (type) {
                  _context35.next = 3;
                  break;
                }
                return _context35.abrupt("return", share);
              case 3:
                return _context35.abrupt("return", this._shareSerializationMiddleware.serialize(share, type));
              case 4:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));
      function outputShare(_x42, _x43) {
        return _outputShare.apply(this, arguments);
      }
      return outputShare;
    }()
  }, {
    key: "inputShare",
    value: function () {
      var _inputShare = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee36(share, type) {
        var shareStore, deserialized, pubPoly, pubPolyID, fullShareIndexesList;
        return regenerator_default().wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                if (this.metadata) {
                  _context36.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                if (type) {
                  _context36.next = 6;
                  break;
                }
                shareStore = this.metadata.shareToShareStore(share);
                _context36.next = 10;
                break;
              case 6:
                _context36.next = 8;
                return this._shareSerializationMiddleware.deserialize(share, type);
              case 8:
                deserialized = _context36.sent;
                shareStore = this.metadata.shareToShareStore(deserialized);
              case 10:
                pubPoly = this.metadata.getLatestPublicPolynomial();
                pubPolyID = pubPoly.getPolynomialID();
                fullShareIndexesList = this.metadata.getShareIndexesForPolynomial(pubPolyID);
                if (fullShareIndexesList.includes(shareStore.share.shareIndex.toString("hex"))) {
                  _context36.next = 15;
                  break;
                }
                throw errors["default"]("Latest poly doesn't include this share");
              case 15:
                _context36.next = 17;
                return this.inputShareStoreSafe(shareStore);
              case 17:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));
      function inputShare(_x44, _x45) {
        return _inputShare.apply(this, arguments);
      }
      return inputShare;
    }()
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        shares: this.shares,
        enableLogging: this.enableLogging,
        privKey: this.privKey ? this.privKey.toString("hex") : undefined,
        metadata: this.metadata,
        lastFetchedCloudMetadata: this.lastFetchedCloudMetadata,
        _localMetadataTransitions: this._localMetadataTransitions,
        manualSync: this.manualSync,
        serviceProvider: this.serviceProvider,
        storageLayer: this.storageLayer
      };
    }
  }, {
    key: "getAllShareStoresForLatestPolynomial",
    value: function getAllShareStoresForLatestPolynomial() {
      var _this10 = this;
      var pubPoly = this.metadata.getLatestPublicPolynomial();
      var pubPolyID = pubPoly.getPolynomialID();
      var existingShareIndexes = this.metadata.getShareIndexesForPolynomial(pubPolyID);
      var threshold = pubPoly.getThreshold();
      var pointsArr = [];
      var sharesForExistingPoly = Object.keys(this.shares[pubPolyID]);
      if (sharesForExistingPoly.length < threshold) {
        throw errors.unableToReconstruct("not enough shares for polynomial reconstruction");
      }
      for (var i = 0; i < threshold; i += 1) {
        pointsArr.push(new common_types_namespaceObject.Point(new (external_bn_js_default())(sharesForExistingPoly[i], "hex"), this.shares[pubPolyID][sharesForExistingPoly[i]].share.share));
      }
      var currentPoly = lagrangeInterpolatePolynomial(pointsArr);
      var allExistingShares = currentPoly.generateShares(existingShareIndexes);
      var shareArray = existingShareIndexes.map(function (shareIndex) {
        return _this10.metadata.shareToShareStore(allExistingShares[shareIndex].share);
      });
      return shareArray;
    }

    /// Destructive method. All data will be wiped!
  }, {
    key: "CRITICAL_deleteTkey",
    value: function () {
      var _CRITICAL_deleteTkey = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee37() {
        var shareArray;
        return regenerator_default().wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (this.metadata) {
                  _context37.next = 2;
                  break;
                }
                throw errors.metadataUndefined();
              case 2:
                if (this.privKey) {
                  _context37.next = 4;
                  break;
                }
                throw errors.privateKeyUnavailable();
              case 4:
                if (!(this._localMetadataTransitions[0].length > 0 || this._localMetadataTransitions[1].length > 0)) {
                  _context37.next = 6;
                  break;
                }
                throw errors["default"]("Please sync all local state before calling this function");
              case 6:
                // Construct all shares
                shareArray = this.getAllShareStoresForLatestPolynomial();
                _context37.next = 9;
                return this.addLocalMetadataTransitions({
                  input: [].concat(toConsumableArray_default()(Array(shareArray.length).fill({
                    message: common_types_namespaceObject.SHARE_DELETED,
                    dateAdded: Date.now()
                  })), [{
                    message: common_types_namespaceObject.KEY_NOT_FOUND
                  }]),
                  privKey: [].concat(toConsumableArray_default()(shareArray.map(function (x) {
                    return x.share.share;
                  })), [undefined])
                });
              case 9:
                _context37.next = 11;
                return this.syncLocalMetadataTransitions();
              case 11:
                // forcesync

                this.privKey = undefined;
                this.metadata = undefined;
                this.shares = {};
                this.lastFetchedCloudMetadata = undefined;
              case 15:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));
      function CRITICAL_deleteTkey() {
        return _CRITICAL_deleteTkey.apply(this, arguments);
      }
      return CRITICAL_deleteTkey;
    }()
  }, {
    key: "getApi",
    value: function getApi() {
      return {
        getMetadata: this.getMetadata.bind(this),
        getStorageLayer: this.getStorageLayer.bind(this),
        initialize: this.initialize.bind(this),
        catchupToLatestShare: this.catchupToLatestShare.bind(this),
        _syncShareMetadata: this._syncShareMetadata.bind(this),
        _addRefreshMiddleware: this._addRefreshMiddleware.bind(this),
        _addReconstructKeyMiddleware: this._addReconstructKeyMiddleware.bind(this),
        _addShareSerializationMiddleware: this._addShareSerializationMiddleware.bind(this),
        addShareDescription: this.addShareDescription.bind(this),
        generateNewShare: this.generateNewShare.bind(this),
        inputShareStore: this.inputShareStore.bind(this),
        inputShareStoreSafe: this.inputShareStoreSafe.bind(this),
        outputShareStore: this.outputShareStore.bind(this),
        inputShare: this.inputShare.bind(this),
        outputShare: this.outputShare.bind(this),
        _setDeviceStorage: this._setDeviceStorage.bind(this),
        encrypt: this.encrypt.bind(this),
        decrypt: this.decrypt.bind(this),
        getTKeyStore: this.getTKeyStore.bind(this),
        getTKeyStoreItem: this.getTKeyStoreItem.bind(this),
        _setTKeyStoreItem: this._setTKeyStoreItem.bind(this),
        _deleteTKeyStoreItem: this._deleteTKeyStoreItem.bind(this),
        deleteShare: this.deleteShare.bind(this)
      };
    }
  }, {
    key: "setModuleReferences",
    value: function setModuleReferences() {
      var _this11 = this;
      Object.keys(this.modules).map(function (x) {
        return _this11.modules[x].setModuleReferences(_this11.getApi());
      });
    }
  }, {
    key: "initializeModules",
    value: function () {
      var _initializeModules = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee38() {
        var _this12 = this;
        return regenerator_default().wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                return _context38.abrupt("return", Promise.all(Object.keys(this.modules).map(function (x) {
                  return _this12.modules[x].initialize();
                })));
              case 1:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));
      function initializeModules() {
        return _initializeModules.apply(this, arguments);
      }
      return initializeModules;
    }()
  }], [{
    key: "fromJSON",
    value: function () {
      var _fromJSON = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee39(value, args) {
        var enableLogging, privKey, metadata, shares, _localMetadataTransitions, manualSync, lastFetchedCloudMetadata, storageLayer, serviceProvider, modules, tb, key, shareStoreMapElement, shareElementKey, shareStore, AuthMetadataKeys, ShareStoreKeys, sampleMessageMetadata, MessageMetadataKeys, localTransitionShares, localTransitionData, tempMetadata, tempCloud, shareToUseForSerialization, latestPolyIDOnCloud, shareIndexesExistInSDK, randomIndex;
        return regenerator_default().wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                enableLogging = value.enableLogging, privKey = value.privKey, metadata = value.metadata, shares = value.shares, _localMetadataTransitions = value._localMetadataTransitions, manualSync = value.manualSync, lastFetchedCloudMetadata = value.lastFetchedCloudMetadata;
                storageLayer = args.storageLayer, serviceProvider = args.serviceProvider, modules = args.modules;
                tb = new ThresholdKey({
                  enableLogging: enableLogging,
                  storageLayer: storageLayer,
                  serviceProvider: serviceProvider,
                  modules: modules,
                  manualSync: manualSync
                });
                if (privKey) tb.privKey = new (external_bn_js_default())(privKey, "hex");
                for (key in shares) {
                  if (Object.prototype.hasOwnProperty.call(shares, key)) {
                    shareStoreMapElement = shares[key];
                    for (shareElementKey in shareStoreMapElement) {
                      if (Object.prototype.hasOwnProperty.call(shareStoreMapElement, shareElementKey)) {
                        shareStore = shareStoreMapElement[shareElementKey];
                        shareStoreMapElement[shareElementKey] = common_types_namespaceObject.ShareStore.fromJSON(shareStore);
                      }
                    }
                  }
                }
                tb.shares = shares;

                // switch to deserialize local metadata transition based on Object.keys() of authMetadata, ShareStore's and, IMessageMetadata
                AuthMetadataKeys = Object.keys(JSON.parse(external_json_stable_stringify_default()(new src_authMetadata(new src_metadata(new common_types_namespaceObject.Point("0", "0")), new (external_bn_js_default())("0", "hex")))));
                ShareStoreKeys = Object.keys(JSON.parse(external_json_stable_stringify_default()(new common_types_namespaceObject.ShareStore(new common_types_namespaceObject.Share("0", "0"), ""))));
                sampleMessageMetadata = {
                  message: "Sample message",
                  dateAdded: Date.now()
                };
                MessageMetadataKeys = Object.keys(sampleMessageMetadata);
                localTransitionShares = [];
                localTransitionData = [];
                _localMetadataTransitions[0].forEach(function (x, index) {
                  if (x) {
                    localTransitionShares.push(new (external_bn_js_default())(x, "hex"));
                  } else {
                    localTransitionShares.push(undefined);
                  }
                  var keys = Object.keys(_localMetadataTransitions[1][index]);
                  if (keys.length === AuthMetadataKeys.length && keys.every(function (val) {
                    return AuthMetadataKeys.includes(val);
                  })) {
                    var tempAuth = src_authMetadata.fromJSON(_localMetadataTransitions[1][index]);
                    tempAuth.privKey = privKey;
                    localTransitionData.push(tempAuth);
                  } else if (keys.length === ShareStoreKeys.length && keys.every(function (val) {
                    return ShareStoreKeys.includes(val);
                  })) {
                    localTransitionData.push(common_types_namespaceObject.ShareStore.fromJSON(_localMetadataTransitions[1][index]));
                  } else if (keys.length === MessageMetadataKeys.length && keys.every(function (val) {
                    return MessageMetadataKeys.includes(val);
                  })) {
                    localTransitionData.push(_localMetadataTransitions[1][index]);
                  } else {
                    throw errors["default"]("fromJSON failed. Could not deserialise _localMetadataTransitions");
                  }
                });
                if (!(metadata || lastFetchedCloudMetadata)) {
                  _context39.next = 21;
                  break;
                }
                // if service provider key is missing, we should initialize with one of the existing shares
                // TODO: fix for deleted share
                if (tb.serviceProvider.postboxKey.toString("hex") === "0") {
                  latestPolyIDOnCloud = src_metadata.fromJSON(lastFetchedCloudMetadata).getLatestPublicPolynomial().getPolynomialID();
                  shareIndexesExistInSDK = Object.keys(shares[latestPolyIDOnCloud]);
                  randomIndex = shareIndexesExistInSDK[Math.floor(Math.random() * (shareIndexesExistInSDK.length - 1))];
                  if (shareIndexesExistInSDK.length >= 1) {
                    shareToUseForSerialization = shares[latestPolyIDOnCloud][randomIndex];
                  }
                }
                if (metadata) tempMetadata = src_metadata.fromJSON(metadata);
                if (lastFetchedCloudMetadata) tempCloud = src_metadata.fromJSON(lastFetchedCloudMetadata);
                _context39.next = 19;
                return tb.initialize({
                  neverInitializeNewKey: true,
                  transitionMetadata: tempMetadata,
                  previouslyFetchedCloudMetadata: tempCloud,
                  previousLocalMetadataTransitions: [localTransitionShares, localTransitionData],
                  withShare: shareToUseForSerialization
                });
              case 19:
                _context39.next = 23;
                break;
              case 21:
                _context39.next = 23;
                return tb.initialize({
                  neverInitializeNewKey: true
                });
              case 23:
                return _context39.abrupt("return", tb);
              case 24:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39);
      }));
      function fromJSON(_x46, _x47) {
        return _fromJSON.apply(this, arguments);
      }
      return fromJSON;
    }()
  }]);
  return ThresholdKey;
}();
/* harmony default export */ const core = (ThresholdKey);
;// CONCATENATED MODULE: ./src/index.ts





module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=core.cjs.js.map